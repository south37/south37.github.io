<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>手を動かして学ぶコンテナ標準 - Container Image と Container Registry 編 | South37's Blog</title><meta name=keywords content><meta name=description content="先日は、コンテナ標準化の現状と Kubernetes の立ち位置について において、各種ドキュメントをベースにコンテナ標準についてまとめてみました。
このブログでは、実際に tool などに触れて手を動かすことで、コンテナ標準についてさらに理解を深めてみたいと思います。
なお、基本的にこのブログ内のコマンドは、Linux で実行するものとします（自分は MacOS で Vagrant で Ubuntu VM を立てて実験してます）。
OCI Image の中身を見てみる skopeo と呼ばれる「container image に対して様々な操作を行えるツール」があります。このツールを利用することで、「docker image から OCI Image への変換」を行うことができます。このツールを利用して、実際に OCI Image の中身を見てみましょう。
まず、以下のコマンドを実行して ruby:2.7.2-slim という docker image を oci:ruby-oci:2.7.2 という名前の OCI Image に変換します。
vagrant@vagrant:~/oci-playground$ skopeo copy docker://ruby:2.7.2-slim oci:ruby-oci:2.7.2 Getting image source signatures Copying blob 852e50cd189d done Copying blob 6de4319615e2 done Copying blob 150eb06190d1 done Copying blob cf654ff9d9df done Copying blob 0a529f6cf42e done Copying config 3265430f5e done Writing manifest to image destination Storing signatures 上記コマンドを実行すると、ruby-oci という directory が出来ています。"><meta name=author content="Nao Minami"><link rel=canonical href=https://www.south37.net/posts/20201210-container-2/><link crossorigin=anonymous href=/assets/css/stylesheet.b183800e2cfbb62c3bce2b2ba56cdb2dd33af76c75cf4550173d5dfebd7c68a6.css integrity="sha256-sYOADiz7tiw7zisrpWzbLdM692x1z0VQFz1d/r18aKY=" rel="preload stylesheet" as=style><link rel=icon href=https://www.south37.net/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.south37.net/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.south37.net/favicon-32x32.png><link rel=apple-touch-icon href=https://www.south37.net/apple-touch-icon.png><link rel=mask-icon href=https://www.south37.net/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="手を動かして学ぶコンテナ標準 - Container Image と Container Registry 編"><meta property="og:description" content="先日は、コンテナ標準化の現状と Kubernetes の立ち位置について において、各種ドキュメントをベースにコンテナ標準についてまとめてみました。
このブログでは、実際に tool などに触れて手を動かすことで、コンテナ標準についてさらに理解を深めてみたいと思います。
なお、基本的にこのブログ内のコマンドは、Linux で実行するものとします（自分は MacOS で Vagrant で Ubuntu VM を立てて実験してます）。
OCI Image の中身を見てみる skopeo と呼ばれる「container image に対して様々な操作を行えるツール」があります。このツールを利用することで、「docker image から OCI Image への変換」を行うことができます。このツールを利用して、実際に OCI Image の中身を見てみましょう。
まず、以下のコマンドを実行して ruby:2.7.2-slim という docker image を oci:ruby-oci:2.7.2 という名前の OCI Image に変換します。
vagrant@vagrant:~/oci-playground$ skopeo copy docker://ruby:2.7.2-slim oci:ruby-oci:2.7.2 Getting image source signatures Copying blob 852e50cd189d done Copying blob 6de4319615e2 done Copying blob 150eb06190d1 done Copying blob cf654ff9d9df done Copying blob 0a529f6cf42e done Copying config 3265430f5e done Writing manifest to image destination Storing signatures 上記コマンドを実行すると、ruby-oci という directory が出来ています。"><meta property="og:type" content="article"><meta property="og:url" content="https://www.south37.net/posts/20201210-container-2/"><meta property="og:image" content="https://www.south37.net/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-12-10T00:00:00+09:00"><meta property="article:modified_time" content="2020-12-10T00:00:00+09:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.south37.net/papermod-cover.png"><meta name=twitter:title content="手を動かして学ぶコンテナ標準 - Container Image と Container Registry 編"><meta name=twitter:description content="先日は、コンテナ標準化の現状と Kubernetes の立ち位置について において、各種ドキュメントをベースにコンテナ標準についてまとめてみました。
このブログでは、実際に tool などに触れて手を動かすことで、コンテナ標準についてさらに理解を深めてみたいと思います。
なお、基本的にこのブログ内のコマンドは、Linux で実行するものとします（自分は MacOS で Vagrant で Ubuntu VM を立てて実験してます）。
OCI Image の中身を見てみる skopeo と呼ばれる「container image に対して様々な操作を行えるツール」があります。このツールを利用することで、「docker image から OCI Image への変換」を行うことができます。このツールを利用して、実際に OCI Image の中身を見てみましょう。
まず、以下のコマンドを実行して ruby:2.7.2-slim という docker image を oci:ruby-oci:2.7.2 という名前の OCI Image に変換します。
vagrant@vagrant:~/oci-playground$ skopeo copy docker://ruby:2.7.2-slim oci:ruby-oci:2.7.2 Getting image source signatures Copying blob 852e50cd189d done Copying blob 6de4319615e2 done Copying blob 150eb06190d1 done Copying blob cf654ff9d9df done Copying blob 0a529f6cf42e done Copying config 3265430f5e done Writing manifest to image destination Storing signatures 上記コマンドを実行すると、ruby-oci という directory が出来ています。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.south37.net/posts/"},{"@type":"ListItem","position":2,"name":"手を動かして学ぶコンテナ標準 - Container Image と Container Registry 編","item":"https://www.south37.net/posts/20201210-container-2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"手を動かして学ぶコンテナ標準 - Container Image と Container Registry 編","name":"手を動かして学ぶコンテナ標準 - Container Image と Container Registry 編","description":"先日は、コンテナ標準化の現状と Kubernetes の立ち位置について において、各種ドキュメントをベースにコンテナ標準についてまとめてみました。\nこのブログでは、実際に tool などに触れて手を動かすことで、コンテナ標準についてさらに理解を深めてみたいと思います。\nなお、基本的にこのブログ内のコマンドは、Linux で実行するものとします（自分は MacOS で Vagrant で Ubuntu VM を立てて実験してます）。\nOCI Image の中身を見てみる skopeo と呼ばれる「container image に対して様々な操作を行えるツール」があります。このツールを利用することで、「docker image から OCI Image への変換」を行うことができます。このツールを利用して、実際に OCI Image の中身を見てみましょう。\nまず、以下のコマンドを実行して ruby:2.7.2-slim という docker image を oci:ruby-oci:2.7.2 という名前の OCI Image に変換します。\nvagrant@vagrant:~/oci-playground$ skopeo copy docker://ruby:2.7.2-slim oci:ruby-oci:2.7.2 Getting image source signatures Copying blob 852e50cd189d done Copying blob 6de4319615e2 done Copying blob 150eb06190d1 done Copying blob cf654ff9d9df done Copying blob 0a529f6cf42e done Copying config 3265430f5e done Writing manifest to image destination Storing signatures 上記コマンドを実行すると、ruby-oci という directory が出来ています。","keywords":[],"articleBody":"先日は、コンテナ標準化の現状と Kubernetes の立ち位置について において、各種ドキュメントをベースにコンテナ標準についてまとめてみました。\nこのブログでは、実際に tool などに触れて手を動かすことで、コンテナ標準についてさらに理解を深めてみたいと思います。\nなお、基本的にこのブログ内のコマンドは、Linux で実行するものとします（自分は MacOS で Vagrant で Ubuntu VM を立てて実験してます）。\nOCI Image の中身を見てみる skopeo と呼ばれる「container image に対して様々な操作を行えるツール」があります。このツールを利用することで、「docker image から OCI Image への変換」を行うことができます。このツールを利用して、実際に OCI Image の中身を見てみましょう。\nまず、以下のコマンドを実行して ruby:2.7.2-slim という docker image を oci:ruby-oci:2.7.2 という名前の OCI Image に変換します。\nvagrant@vagrant:~/oci-playground$ skopeo copy docker://ruby:2.7.2-slim oci:ruby-oci:2.7.2 Getting image source signatures Copying blob 852e50cd189d done Copying blob 6de4319615e2 done Copying blob 150eb06190d1 done Copying blob cf654ff9d9df done Copying blob 0a529f6cf42e done Copying config 3265430f5e done Writing manifest to image destination Storing signatures 上記コマンドを実行すると、ruby-oci という directory が出来ています。\nvagrant@vagrant:~/oci-playground$ ls ruby-oci ruby-oci directory の中を見てみると、以下のように blobs という direcyory と index.json, oci-layout という file が出来ています。これは、OCI Image Format Specification で定められた Image Layout の内容に一致しています。\nvagrant@vagrant:~/oci-playground/ruby-oci$ ls blobs index.json oci-layout oci-layout file には imageLayoutVersion だけが記載されています。現時点では 1.0.0 が記載されているだけなので、将来の拡張のための file と考えると良いでしょう。\nvagrant@vagrant:~/oci-playground/ruby-oci$ cat oci-layout | jq . { \"imageLayoutVersion\": \"1.0.0\" } index.json は OCI Image のエントリーポイントとも呼べる file で、ここには以下のように「manifest fileへの参照（= Image Manifest を指し示す Content Descriptor）」が記載されています。\nvagrant@vagrant:~/oci-playground/ruby-oci$ cat index.json | jq . { \"schemaVersion\": 2, \"manifests\": [ { \"mediaType\": \"application/vnd.oci.image.manifest.v1+json\", \"digest\": \"sha256:ad39959791540e6213fbe4675b9f3ee11e96456df3601b0936973ca7ae766bd7\", \"size\": 976, \"annotations\": { \"org.opencontainers.image.ref.name\": \"2.7.2\" } } ] } ここで出てきた「Content Descriptor」というのが OCI Image Format において特徴的なもので、これは「mediaType, digest, size の 3 つ組 + optional な情報 (e.g. annotations)」となっています。 mediaType が参照先の情報の種類、digest が参照先の情報の path、size が参照先の情報のバイト数を表しています。\ndigest で示されているのは「blobs directory 以下の file path」になっていて、例えば上記の sha256:ad39959791540e6213fbe4675b9f3ee11e96456df3601b0936973ca7ae766bd7 という digest は blobs/sha256/ad39959791540e6213fbe4675b9f3ee11e96456df3601b0936973ca7ae766bd7 という path を表しています。実際に、file の中身を見てみると以下のような JSON になっています。\nvagrant@vagrant:~/oci-playground/ruby-oci$ cat blobs/sha256/ad39959791540e6213fbe4675b9f3ee11e96456df3601b0936973ca7ae766bd7 | jq . { \"schemaVersion\": 2, \"config\": { \"mediaType\": \"application/vnd.oci.image.config.v1+json\", \"digest\": \"sha256:3265430f5e5babe0664d7f7bcc77db2ef7d5feaa1625c06c10b1409ad2952133\", \"size\": 4598 }, \"layers\": [ { \"mediaType\": \"application/vnd.oci.image.layer.v1.tar+gzip\", \"digest\": \"sha256:852e50cd189dfeb54d97680d9fa6bed21a6d7d18cfb56d6abfe2de9d7f173795\", \"size\": 27105484 }, { \"mediaType\": \"application/vnd.oci.image.layer.v1.tar+gzip\", \"digest\": \"sha256:6de4319615e27e1aaaadc89b43db39ea0e118f47eeecfa4c8b910ca2fd810653\", \"size\": 12539406 }, { \"mediaType\": \"application/vnd.oci.image.layer.v1.tar+gzip\", \"digest\": \"sha256:150eb06190d1ba56f7b998da25a140c21258bca436d33e2e77df679d77ab364a\", \"size\": 198 }, { \"mediaType\": \"application/vnd.oci.image.layer.v1.tar+gzip\", \"digest\": \"sha256:cf654ff9d9df475122683b6bd070fa57a1e1969ced2a45f2c1f76a0678495ef2\", \"size\": 22852677 }, { \"mediaType\": \"application/vnd.oci.image.layer.v1.tar+gzip\", \"digest\": \"sha256:0a529f6cf42e0fb49fe3fb4d12e232b26db923ab85a442563b0a7ae0a28c5971\", \"size\": 143 } ] } mediaType が application/vnd.oci.image.manifest.v1+json だったことから、これは Image Manifest であると分かります。実際に、Image Manifest の仕様で定義された内容と一致しており、config （Container Image のメタデータ）や layers （Container Image の Layer、Docker Image における Layer Cache の単位となるもの）を情報として持つことも分かります。また、それらの情報への参照も、先ほどと同様の Content Descriptor 形式で表されていることが分かります。\nconfig の内容は、以下のような Image Configuration となっています。環境変数や Command など Container 実行時に必要な各種メタデータや、Container Image 作成時の history の情報が記載されています。\nvagrant@vagrant:~/oci-playground/ruby-oci$ cat blobs/sha256/3265430f5e5babe0664d7f7bcc77db2ef7d5feaa1625c06c10b1409ad2952133 | jq . { \"created\": \"2020-11-18T15:35:15.373100656Z\", \"architecture\": \"amd64\", \"os\": \"linux\", \"config\": { \"Env\": [ \"PATH=/usr/local/bundle/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", \"LANG=C.UTF-8\", \"RUBY_MAJOR=2.7\", \"RUBY_VERSION=2.7.2\", \"RUBY_DOWNLOAD_SHA256=1b95ab193cc8f5b5e59d2686cb3d5dcf1ddf2a86cb6950e0b4bdaae5040ec0d6\", \"GEM_HOME=/usr/local/bundle\", \"BUNDLE_SILENCE_ROOT_WARNING=1\", \"BUNDLE_APP_CONFIG=/usr/local/bundle\" ], \"Cmd\": [ \"irb\" ] }, \"rootfs\": { \"type\": \"layers\", \"diff_ids\": [ \"sha256:f5600c6330da7bb112776ba067a32a9c20842d6ecc8ee3289f1a713b644092f8\", \"sha256:70ca8ae918406dce7acc5fe0f49e45b9275a266b83e275922e67358976c2929e\", \"sha256:e8ace463e6f7085a5439cf3b578a080fbefc8ad8424b59b9f35590adb1509763\", \"sha256:71e4ad27368acf7dbb5c90aa65d67cc462267836aa220cbafb9bb62acd9d48de\", \"sha256:1946ed62a3cb062940077a7a1dbfc93d55be6ef3d4f605883b42f71970381662\" ] }, \"history\": [ { \"created\": \"2020-11-17T20:21:17.570073346Z\", \"created_by\": \"/bin/sh -c #(nop) ADD file:d2abb0e4e7ac1773741f51f57d3a0b8ffc7907348842d773f8c341ba17f856d5 in / \" }, { \"created\": \"2020-11-17T20:21:17.865210281Z\", \"created_by\": \"/bin/sh -c #(nop) CMD [\\\"bash\\\"]\", \"empty_layer\": true }, { \"created\": \"2020-11-18T15:21:22.717162717Z\", \"created_by\": \"/bin/sh -c set -eux; \\tapt-get update; \\tapt-get install -y --no-install-recommends \\t\\tbzip2 \\t\\tca-certificates \\t\\tlibffi-dev \\t\\tlibgmp-dev \\t\\tlibssl-dev \\t\\tlibyaml-dev \\t\\tprocps \\t\\tzlib1g-dev \\t; \\trm -rf /var/lib/apt/lists/*\" }, { \"created\": \"2020-11-18T15:21:23.811888513Z\", \"created_by\": \"/bin/sh -c set -eux; \\tmkdir -p /usr/local/etc; \\t{ \\t\\techo 'install: --no-document'; \\t\\techo 'update: --no-document'; \\t} \u003e\u003e /usr/local/etc/gemrc\" }, { \"created\": \"2020-11-18T15:21:24.004412503Z\", \"created_by\": \"/bin/sh -c #(nop) ENV LANG=C.UTF-8\", \"empty_layer\": true }, { \"created\": \"2020-11-18T15:30:41.383881949Z\", \"created_by\": \"/bin/sh -c #(nop) ENV RUBY_MAJOR=2.7\", \"empty_layer\": true }, { \"created\": \"2020-11-18T15:30:41.629378277Z\", \"created_by\": \"/bin/sh -c #(nop) ENV RUBY_VERSION=2.7.2\", \"empty_layer\": true }, { \"created\": \"2020-11-18T15:30:41.868222399Z\", \"created_by\": \"/bin/sh -c #(nop) ENV RUBY_DOWNLOAD_SHA256=1b95ab193cc8f5b5e59d2686cb3d5dcf1ddf2a86cb6950e0b4bdaae5040ec0d6\", \"empty_layer\": true }, { \"created\": \"2020-11-18T15:35:11.770005784Z\", \"created_by\": \"/bin/sh -c set -eux; \\t\\tsavedAptMark=\\\"$(apt-mark showmanual)\\\"; \\tapt-get update; \\tapt-get install -y --no-install-recommends \\t\\tautoconf \\t\\tbison \\t\\tdpkg-dev \\t\\tgcc \\t\\tlibbz2-dev \\t\\tlibgdbm-compat-dev \\t\\tlibgdbm-dev \\t\\tlibglib2.0-dev \\t\\tlibncurses-dev \\t\\tlibreadline-dev \\t\\tlibxml2-dev \\t\\tlibxslt-dev \\t\\tmake \\t\\truby \\t\\twget \\t\\txz-utils \\t; \\trm -rf /var/lib/apt/lists/*; \\t\\twget -O ruby.tar.xz \\\"https://cache.ruby-lang.org/pub/ruby/${RUBY_MAJOR%-rc}/ruby-$RUBY_VERSION.tar.xz\\\"; \\techo \\\"$RUBY_DOWNLOAD_SHA256 *ruby.tar.xz\\\" | sha256sum --check --strict; \\t\\tmkdir -p /usr/src/ruby; \\ttar -xJf ruby.tar.xz -C /usr/src/ruby --strip-components=1; \\trm ruby.tar.xz; \\t\\tcd /usr/src/ruby; \\t\\t{ \\t\\techo '#define ENABLE_PATH_CHECK 0'; \\t\\techo; \\t\\tcat file.c; \\t} \u003e file.c.new; \\tmv file.c.new file.c; \\t\\tautoconf; \\tgnuArch=\\\"$(dpkg-architecture --query DEB_BUILD_GNU_TYPE)\\\"; \\t./configure \\t\\t--build=\\\"$gnuArch\\\" \\t\\t--disable-install-doc \\t\\t--enable-shared \\t; \\tmake -j \\\"$(nproc)\\\"; \\tmake install; \\t\\tapt-mark auto '.*' \u003e /dev/null; \\tapt-mark manual $savedAptMark \u003e /dev/null; \\tfind /usr/local -type f -executable -not \\\\( -name '*tkinter*' \\\\) -exec ldd '{}' ';' \\t\\t| awk '/=\u003e/ { print $(NF-1) }' \\t\\t| sort -u \\t\\t| xargs -r dpkg-query --search \\t\\t| cut -d: -f1 \\t\\t| sort -u \\t\\t| xargs -r apt-mark manual \\t; \\tapt-get purge -y --auto-remove -o APT::AutoRemove::RecommendsImportant=false; \\t\\tcd /; \\trm -r /usr/src/ruby; \\t! dpkg -l | grep -i ruby; \\t[ \\\"$(command -v ruby)\\\" = '/usr/local/bin/ruby' ]; \\truby --version; \\tgem --version; \\tbundle --version\" }, { \"created\": \"2020-11-18T15:35:12.227711802Z\", \"created_by\": \"/bin/sh -c #(nop) ENV GEM_HOME=/usr/local/bundle\", \"empty_layer\": true }, { \"created\": \"2020-11-18T15:35:12.563337139Z\", \"created_by\": \"/bin/sh -c #(nop) ENV BUNDLE_SILENCE_ROOT_WARNING=1 BUNDLE_APP_CONFIG=/usr/local/bundle\", \"empty_layer\": true }, { \"created\": \"2020-11-18T15:35:12.907595531Z\", \"created_by\": \"/bin/sh -c #(nop) ENV PATH=/usr/local/bundle/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", \"empty_layer\": true }, { \"created\": \"2020-11-18T15:35:14.977063521Z\", \"created_by\": \"/bin/sh -c mkdir -p \\\"$GEM_HOME\\\" \u0026\u0026 chmod 777 \\\"$GEM_HOME\\\"\" }, { \"created\": \"2020-11-18T15:35:15.373100656Z\", \"created_by\": \"/bin/sh -c #(nop) CMD [\\\"irb\\\"]\", \"empty_layer\": true } ] } layers は Filesystem Layer を表しています。tar+gzip という mediaType の suffix は「gzip 圧縮された tar archive」を表しています。試しに、最も root にあった sha256:852e50cd189dfeb54d97680d9fa6bed21a6d7d18cfb56d6abfe2de9d7f173795 の中身を見てみます。\nvagrant@vagrant:~/oci-playground/ruby-oci$ mkdir rootfs vagrant@vagrant:~/oci-playground/ruby-oci$ tar xvzf blobs/sha256/852e50cd189dfeb54d97680d9fa6bed21a6d7d18cfb56d6abfe2de9d7f173795 -C rootfs/ . . . 上記コマンドで、rootfs directory 以下に圧縮されていた中身が展開されます（注: tar: bin/uncompress: Cannot hard link to ‘bin/gunzip’: Operation not permitted など一部の file について error は出ていて、そのせいで tar: Exiting with failure status due to previous errors という失敗 message も出てしまいましたが、それはここでは無視します）。\nrootfs の中身を見てみると、以下のようにいくつかの directyory が並んでいます。\nvagrant@vagrant:~/oci-playground/ruby-oci$ ls rootfs/ bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var 試しに変換前の ruby:2.7.2-slim docker image を利用して container を起動してみると、root directory の中身がそっくりであることが確認できます。\n$ docker run -it ruby:2.7.2-slim bash root@f6be3c7c619d:/# ls / bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var 実は、これらの layer が「どう apply されるのか」は Image Layer Filesystem Changeset の Applying Changesets というセクション の中で以下のように明確に定義されています。ざっくり言えば「layer の上から順に tar archive を展開したようなもの」になります。 「file や directory の削除」は Whiteouts と呼ばれる特別な仕様で表現されますが、特別に注意を払う必要があるのはそれくらいのようです。\nApplying Changesets Layer Changesets of media type application/vnd.oci.image.layer.v1.tar are applied, rather than simply extracted as tar archives. Applying a layer changeset requires special consideration for the whiteout files. In the absence of any whiteout files in a layer changeset, the archive is extracted like a regular tar archive. cf. https://github.com/opencontainers/image-spec/blob/v1.0.1/layer.md#applying-changesets\nということで、OCI image の中身に目を通してみました。「Conatainer を走らせるために必要な情報（= 実行時のメタデータ + Layer 化された filesystem の情報）」が格納されてることがわかったかと思います。\nContainer Registry との通信内容を見てみる ここまでで、「Container Image の内容」については把握できました。次に、「Container Registry から Container Image をどのように pull しているのか」を調べてみましょう。\n現在、各種 Container Registry は Docker 社が公開している Docker Registry HTTP API V2 と呼ばれる仕様に従う形で Container Image の Pull を出来るようにしています。実は、「Container Image の Pull」にあたる操作はただの HTTP request であるため、$ curl を利用して実行する事ができます。ここでは、実際に $ curl で request してみることで、Container Registry との通信内容を見てみる事にしましょう。\nなお、自分が試した範囲では、どの Container Image も OCI Image Format ではなく Docker Image Manifest V 2, Schema 2 に従う形の response を返してきました。ただ、OCI Image Format と Docker Image V2.2 は一部の mediaType 名を除いてほぼ同一なので、先ほど眺めた内容は理解に役立つはずです。\nさて、実際に curl で request を送ってみましょう。対象 Container Image は何でも良いのですが、ここでは https://github.com/GoogleContainerTools/base-images-docker に記載されてる Debian の Container Image である gcr.io/google-appengine/debian9 を対象にしてみます。\nまず、以下のように Container Registry の Authentication に必要な Token を取得します。この時、「google-appengine/debian9 の pull」という形で scope を指定しておきます。\n$ export TOKEN=$(curl \"https://gcr.io/v2/token?service=gcr.io\u0026scope=repository:google-appengine/debian9:pull\" | jq -r '.token') % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 453 0 453 0 0 1088 0 --:--:-- --:--:-- --:--:-- 1088 次に、https://gcr.io/v2//manifests/ へ先ほど取得した Token 付きで GET request を送ります。こうすると、Docker Image V2.2 における manifest file が取得できます。\n$ curl -H \"Authorization: Bearer ${TOKEN}\" https://gcr.io/v2/google-appengine/debian9/manifests/latest | jq . % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 528 100 528 0 0 469 0 0:00:01 0:00:01 --:--:-- 469 { \"schemaVersion\": 2, \"mediaType\": \"application/vnd.docker.distribution.manifest.v2+json\", \"config\": { \"mediaType\": \"application/vnd.docker.container.image.v1+json\", \"size\": 463, \"digest\": \"sha256:18c47921b263ac67af3d654e3b485c998d1e6bab56edc5a15b6b7a8fad3ac18a\" }, \"layers\": [ { \"mediaType\": \"application/vnd.docker.image.rootfs.diff.tar.gzip\", \"size\": 47965538, \"digest\": \"sha256:faa9d9046d25e5fd30ac4444c7b6c30a1a6fff7c461410547156aed2001668a1\" } ] } まず、config の中身を見てみましょう。\ndigest を利用して参照を辿る際は https://gcr.io/v2//blobs/ へ request すれば良いです。実際に request してみると、以下のような response が返ってきます。先ほど OCI Image の中身を見てみた時と同様に、Container 実行に必要なメタデータが格納されていることが分かります。\n$ curl -L -H \"Authorization: Bearer ${TOKEN}\" https://gcr.io/v2/google-appengine/debian9/blobs/sha256:18c47921b263ac67af3d654e3b485c998d1e6bab56edc5a15b6b7a8fad3ac18a | jq . % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 13 0 13 0 0 23 0 --:--:-- --:--:-- --:--:-- 23 100 463 100 463 0 0 750 0 --:--:-- --:--:-- --:--:-- 750 { \"architecture\": \"amd64\", \"author\": \"Bazel\", \"created\": \"1970-01-01T00:00:00Z\", \"history\": [ { \"author\": \"Bazel\", \"created\": \"1970-01-01T00:00:00Z\", \"created_by\": \"bazel build ...\" } ], \"os\": \"linux\", \"rootfs\": { \"type\": \"layers\", \"diff_ids\": [ \"sha256:0a3dcb016bd8a852985044291de00ad6a6b94dcb0eac01b34b56afed409b9999\" ] }, \"config\": { \"Cmd\": [ \"/bin/sh\", \"-c\", \"/bin/bash\" ], \"Env\": [ \"DEBIAN_FRONTEND=noninteractive\", \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", \"PORT=8080\" ] } } なお、注意点として、どうやら GCR は https://gcr.io/v2//blobs/ への request では Google Cloud Storage への redirect response を返すようです。-L オプションを付けない場合は以下のような結果になることには留意してください。\n$ curl --include -H \"Authorization: Bearer ${TOKEN}\" https://gcr.io/v2/google-appengine/debian9/blobs/sha256:18c47921b263ac67af3d654e3b485c998d1e6bab56edc5a15b6b7a8fad3ac18a HTTP/2 302 docker-distribution-api-version: registry/2.0 location: https://storage.googleapis.com/artifacts.google-appengine.appspot.com/containers/images/sha256:18c47921b263ac67af3d654e3b485c998d1e6bab56edc5a15b6b7a8fad3ac18a content-type: application/json date: Wed, 09 Dec 2020 13:38:51 GMT server: Docker Registry cache-control: private x-xss-protection: 0 x-frame-options: SAMEORIGIN alt-svc: h3-29=\":443\"; ma=2592000,h3-T051=\":443\"; ma=2592000,h3-Q050=\":443\"; ma=2592000,h3-Q046=\":443\"; ma=2592000,h3-Q043=\":443\"; ma=2592000,quic=\":443\"; ma=2592000; v=\"46,43\" accept-ranges: none vary: Accept-Encoding {\"errors\":[]}% 上記では config の取得を行いましたが、Layer （mediaType: application/vnd.docker.image.rootfs.diff.tar.gzip のデータ）についても同様にhttps://gcr.io/v2//blobs/ への request によって取得する事ができます。先ほどと同様に、tar コマンドで展開すると container 実行に利用される file を取得することが出来ます。\n$ curl -L -H \"Authorization: Bearer ${TOKEN}\" https://gcr.io/v2/google-appengine/debian9/blobs/sha256:faa9d9046d25e5fd30ac4444c7b6c30a1a6fff7c461410547156aed2001668a1 --output /tmp/faa9d9046d25e5fd30ac4444c7b6c30a1a6fff7c461410547156aed2001668a1 % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 13 0 13 0 0 28 0 --:--:-- --:--:-- --:--:-- 28 100 45.7M 100 45.7M 0 0 13.6M 0 0:00:03 0:00:03 --:--:-- 20.1M $ ls -la /tmp/faa9d9046d25e5fd30ac4444c7b6c30a1a6fff7c461410547156aed2001668a1 -rw-r--r-- 1 minami wheel 47965538 Dec 9 23:48 /tmp/faa9d9046d25e5fd30ac4444c7b6c30a1a6fff7c461410547156aed2001668a1 $ mkdir /tmp/rootfs $ tar xvzf /tmp/faa9d9046d25e5fd30ac4444c7b6c30a1a6fff7c461410547156aed2001668a1 -C /tmp/rootfs/ $ ls /tmp/rootfs bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var という事で、Container Registry との通信について、特に「Container Image の Pull」に絞って通信内容を見てみました。Docker Image V2.2 をベースにした通信である事、特に config や layer などがそれぞれの単位で通信できることなどが分かったかと思います。より詳しい内容が気になる場合は、Docker Registry HTTP API V2 を参照してみてください。\nなお、「Container Image 全てをまとめた file を一括でダウンロードしないのは何故なのか？」という疑問についてですが、これは自分の理解では「Layer Cache を効かせた形での Image Pull を実現するため」だと捉えています。Layer のデータは巨大であるため最低限の通信で済ませたいというのが大前提にあり、そのために「コンテンツの中身を反映した digest 値を用いて、Layer ごとに通信する」という振る舞いになっているのだと思われます。\nまとめ OCI image を実際に作成して眺めて見ることで、Container Image について理解を深めました。また、curl で Container Registry との通信を行うことで、Container Registry との通信内容についても理解を深める事が出来ました。\nドキュメントを読むだけだとどうしても理解が曖昧になってしまいがちですが、実際に手を動かす事で具体的な動作をイメージ出来るようになります。このブログ自体は自分の理解のために試したことをまとめたものですが、誰か他の人にとっても理解を助けるものになっていれば幸いです。\nなお、今回は Container Image + Container Registry 編でしたが、後日 Container Runtime についても「手を動かして調べた内容」についてまとめたいと思っています。特に、「Container Image から Container Runtime が利用する Filesystem Bundle への Conversion」や、「runc などの low-level Container Runtime の動作」、「containerd や CRI-O などの high-level Container Runtime の動作」について試したことをまとめる予定です。\n補足: Vagrant での実験環境 以下のような Vagrantfile を使ってます。ubuntu-20.04 を使ってます。\n# -*- mode: ruby -*- # vi: set ft=ruby : VAGRANTFILE_API_VERSION = \"2\" Vagrant.configure(VAGRANTFILE_API_VERSION) do |config| config.vm.box = \"bento/ubuntu-20.04\" end 参考文献 以下のブログは、ツールやコマンド、内容において大幅に参考にさせて頂きました。ありがとうございました。\nhttps://blog.unasuke.com/2018/read-oci-image-spec-v101/ https://knqyf263.hatenablog.com/entry/2019/11/29/052818 ","wordCount":"1532","inLanguage":"en","datePublished":"2020-12-10T00:00:00+09:00","dateModified":"2020-12-10T00:00:00+09:00","author":{"@type":"Person","name":"Nao Minami"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.south37.net/posts/20201210-container-2/"},"publisher":{"@type":"Organization","name":"South37's Blog","logo":{"@type":"ImageObject","url":"https://www.south37.net/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://www.south37.net/ accesskey=h title="South37's Blog (Alt + H)">South37's Blog</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://www.south37.net/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://www.south37.net/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.south37.net/>Home</a>&nbsp;»&nbsp;<a href=https://www.south37.net/posts/>Posts</a></div><h1 class=post-title>手を動かして学ぶコンテナ標準 - Container Image と Container Registry 編</h1><div class=post-meta><span title='2020-12-10 00:00:00 +0900 +0900'>December 10, 2020</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Nao Minami</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#oci-image-%e3%81%ae%e4%b8%ad%e8%ba%ab%e3%82%92%e8%a6%8b%e3%81%a6%e3%81%bf%e3%82%8b aria-label="OCI Image の中身を見てみる">OCI Image の中身を見てみる</a><ul><li><a href=#applying-changesets aria-label="Applying Changesets">Applying Changesets</a></li></ul></li><li><a href=#container-registry-%e3%81%a8%e3%81%ae%e9%80%9a%e4%bf%a1%e5%86%85%e5%ae%b9%e3%82%92%e8%a6%8b%e3%81%a6%e3%81%bf%e3%82%8b aria-label="Container Registry との通信内容を見てみる">Container Registry との通信内容を見てみる</a></li><li><a href=#%e3%81%be%e3%81%a8%e3%82%81 aria-label=まとめ>まとめ</a></li><li><a href=#%e8%a3%9c%e8%b6%b3-vagrant-%e3%81%a7%e3%81%ae%e5%ae%9f%e9%a8%93%e7%92%b0%e5%a2%83 aria-label="補足: Vagrant での実験環境">補足: Vagrant での実験環境</a></li><li><a href=#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae aria-label=参考文献>参考文献</a></li></ul></div></details></div><div class=post-content><p>先日は、<a href=/posts/20201207-container-1>コンテナ標準化の現状と Kubernetes の立ち位置について</a> において、各種ドキュメントをベースにコンテナ標準についてまとめてみました。</p><p>このブログでは、実際に tool などに触れて手を動かすことで、コンテナ標準についてさらに理解を深めてみたいと思います。</p><p>なお、基本的にこのブログ内のコマンドは、Linux で実行するものとします（自分は MacOS で Vagrant で Ubuntu VM を立てて実験してます）。</p><h2 id=oci-image-の中身を見てみる>OCI Image の中身を見てみる<a hidden class=anchor aria-hidden=true href=#oci-image-の中身を見てみる>#</a></h2><p><a href=https://github.com/containers/skopeo>skopeo</a> と呼ばれる「container image に対して様々な操作を行えるツール」があります。このツールを利用することで、「docker image から OCI Image への変換」を行うことができます。このツールを利用して、実際に OCI Image の中身を見てみましょう。</p><p>まず、以下のコマンドを実行して <code>ruby:2.7.2-slim</code> という docker image を <code>oci:ruby-oci:2.7.2</code> という名前の OCI Image に変換します。</p><pre tabindex=0><code>vagrant@vagrant:~/oci-playground$ skopeo copy docker://ruby:2.7.2-slim oci:ruby-oci:2.7.2
Getting image source signatures
Copying blob 852e50cd189d done
Copying blob 6de4319615e2 done
Copying blob 150eb06190d1 done
Copying blob cf654ff9d9df done
Copying blob 0a529f6cf42e done
Copying config 3265430f5e done
Writing manifest to image destination
Storing signatures
</code></pre><p>上記コマンドを実行すると、ruby-oci という directory が出来ています。</p><pre tabindex=0><code>vagrant@vagrant:~/oci-playground$ ls
ruby-oci
</code></pre><p><code>ruby-oci</code> directory の中を見てみると、以下のように <code>blobs</code> という direcyory と <code>index.json</code>, <code>oci-layout</code> という file が出来ています。これは、OCI Image Format Specification で定められた <a href=https://github.com/opencontainers/image-spec/blob/v1.0.1/image-layout.md>Image Layout</a> の内容に一致しています。</p><pre tabindex=0><code>vagrant@vagrant:~/oci-playground/ruby-oci$ ls
blobs  index.json  oci-layout
</code></pre><p>oci-layout file には <code>imageLayoutVersion</code> だけが記載されています。現時点では <code>1.0.0</code> が記載されているだけなので、将来の拡張のための file と考えると良いでしょう。</p><pre tabindex=0><code>vagrant@vagrant:~/oci-playground/ruby-oci$ cat oci-layout | jq .
{
  &#34;imageLayoutVersion&#34;: &#34;1.0.0&#34;
}
</code></pre><p>index.json は OCI Image のエントリーポイントとも呼べる file で、ここには以下のように「manifest fileへの参照（= <a href=https://github.com/opencontainers/image-spec/blob/v1.0.1/manifest.md>Image Manifest</a> を指し示す <a href=https://github.com/opencontainers/image-spec/blob/v1.0.1/descriptor.md>Content Descriptor</a>）」が記載されています。</p><pre tabindex=0><code>vagrant@vagrant:~/oci-playground/ruby-oci$ cat index.json | jq .
{
  &#34;schemaVersion&#34;: 2,
  &#34;manifests&#34;: [
    {
      &#34;mediaType&#34;: &#34;application/vnd.oci.image.manifest.v1+json&#34;,
      &#34;digest&#34;: &#34;sha256:ad39959791540e6213fbe4675b9f3ee11e96456df3601b0936973ca7ae766bd7&#34;,
      &#34;size&#34;: 976,
      &#34;annotations&#34;: {
        &#34;org.opencontainers.image.ref.name&#34;: &#34;2.7.2&#34;
      }
    }
  ]
}
</code></pre><p>ここで出てきた「<a href=https://github.com/opencontainers/image-spec/blob/v1.0.1/descriptor.md>Content Descriptor</a>」というのが OCI Image Format において特徴的なもので、これは「<code>mediaType</code>, <code>digest</code>, <code>size</code> の 3 つ組 + optional な情報 (e.g. annotations)」となっています。
<code>mediaType</code> が参照先の情報の種類、<code>digest</code> が参照先の情報の path、<code>size</code> が参照先の情報のバイト数を表しています。</p><p>digest で示されているのは「<code>blobs</code> directory 以下の file path」になっていて、例えば上記の <code>sha256:ad39959791540e6213fbe4675b9f3ee11e96456df3601b0936973ca7ae766bd7</code> という digest は <code>blobs/sha256/ad39959791540e6213fbe4675b9f3ee11e96456df3601b0936973ca7ae766bd7</code> という path を表しています。実際に、file の中身を見てみると以下のような JSON になっています。</p><pre tabindex=0><code>vagrant@vagrant:~/oci-playground/ruby-oci$ cat blobs/sha256/ad39959791540e6213fbe4675b9f3ee11e96456df3601b0936973ca7ae766bd7 | jq .
{
  &#34;schemaVersion&#34;: 2,
  &#34;config&#34;: {
    &#34;mediaType&#34;: &#34;application/vnd.oci.image.config.v1+json&#34;,
    &#34;digest&#34;: &#34;sha256:3265430f5e5babe0664d7f7bcc77db2ef7d5feaa1625c06c10b1409ad2952133&#34;,
    &#34;size&#34;: 4598
  },
  &#34;layers&#34;: [
    {
      &#34;mediaType&#34;: &#34;application/vnd.oci.image.layer.v1.tar+gzip&#34;,
      &#34;digest&#34;: &#34;sha256:852e50cd189dfeb54d97680d9fa6bed21a6d7d18cfb56d6abfe2de9d7f173795&#34;,
      &#34;size&#34;: 27105484
    },
    {
      &#34;mediaType&#34;: &#34;application/vnd.oci.image.layer.v1.tar+gzip&#34;,
      &#34;digest&#34;: &#34;sha256:6de4319615e27e1aaaadc89b43db39ea0e118f47eeecfa4c8b910ca2fd810653&#34;,
      &#34;size&#34;: 12539406
    },
    {
      &#34;mediaType&#34;: &#34;application/vnd.oci.image.layer.v1.tar+gzip&#34;,
      &#34;digest&#34;: &#34;sha256:150eb06190d1ba56f7b998da25a140c21258bca436d33e2e77df679d77ab364a&#34;,
      &#34;size&#34;: 198
    },
    {
      &#34;mediaType&#34;: &#34;application/vnd.oci.image.layer.v1.tar+gzip&#34;,
      &#34;digest&#34;: &#34;sha256:cf654ff9d9df475122683b6bd070fa57a1e1969ced2a45f2c1f76a0678495ef2&#34;,
      &#34;size&#34;: 22852677
    },
    {
      &#34;mediaType&#34;: &#34;application/vnd.oci.image.layer.v1.tar+gzip&#34;,
      &#34;digest&#34;: &#34;sha256:0a529f6cf42e0fb49fe3fb4d12e232b26db923ab85a442563b0a7ae0a28c5971&#34;,
      &#34;size&#34;: 143
    }
  ]
}
</code></pre><p><code>mediaType</code> が <code>application/vnd.oci.image.manifest.v1+json</code> だったことから、これは <a href=https://github.com/opencontainers/image-spec/blob/v1.0.1/manifest.md>Image Manifest</a> であると分かります。実際に、<a href=https://github.com/opencontainers/image-spec/blob/v1.0.1/manifest.md>Image Manifest の仕様</a>で定義された内容と一致しており、<a href=https://github.com/opencontainers/image-spec/blob/v1.0.1/config.md>config</a> （Container Image のメタデータ）や <a href=https://github.com/opencontainers/image-spec/blob/v1.0.1/layer.md>layers</a> （Container Image の Layer、Docker Image における Layer Cache の単位となるもの）を情報として持つことも分かります。また、それらの情報への参照も、先ほどと同様の <a href=https://github.com/opencontainers/image-spec/blob/v1.0.1/descriptor.md>Content Descriptor</a> 形式で表されていることが分かります。</p><p><code>config</code> の内容は、以下のような <a href=https://github.com/opencontainers/image-spec/blob/v1.0.1/config.md>Image Configuration</a> となっています。環境変数や Command など Container 実行時に必要な各種メタデータや、Container Image 作成時の history の情報が記載されています。</p><pre tabindex=0><code>vagrant@vagrant:~/oci-playground/ruby-oci$ cat blobs/sha256/3265430f5e5babe0664d7f7bcc77db2ef7d5feaa1625c06c10b1409ad2952133 | jq .
{
  &#34;created&#34;: &#34;2020-11-18T15:35:15.373100656Z&#34;,
  &#34;architecture&#34;: &#34;amd64&#34;,
  &#34;os&#34;: &#34;linux&#34;,
  &#34;config&#34;: {
    &#34;Env&#34;: [
      &#34;PATH=/usr/local/bundle/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&#34;,
      &#34;LANG=C.UTF-8&#34;,
      &#34;RUBY_MAJOR=2.7&#34;,
      &#34;RUBY_VERSION=2.7.2&#34;,
      &#34;RUBY_DOWNLOAD_SHA256=1b95ab193cc8f5b5e59d2686cb3d5dcf1ddf2a86cb6950e0b4bdaae5040ec0d6&#34;,
      &#34;GEM_HOME=/usr/local/bundle&#34;,
      &#34;BUNDLE_SILENCE_ROOT_WARNING=1&#34;,
      &#34;BUNDLE_APP_CONFIG=/usr/local/bundle&#34;
    ],
    &#34;Cmd&#34;: [
      &#34;irb&#34;
    ]
  },
  &#34;rootfs&#34;: {
    &#34;type&#34;: &#34;layers&#34;,
    &#34;diff_ids&#34;: [
      &#34;sha256:f5600c6330da7bb112776ba067a32a9c20842d6ecc8ee3289f1a713b644092f8&#34;,
      &#34;sha256:70ca8ae918406dce7acc5fe0f49e45b9275a266b83e275922e67358976c2929e&#34;,
      &#34;sha256:e8ace463e6f7085a5439cf3b578a080fbefc8ad8424b59b9f35590adb1509763&#34;,
      &#34;sha256:71e4ad27368acf7dbb5c90aa65d67cc462267836aa220cbafb9bb62acd9d48de&#34;,
      &#34;sha256:1946ed62a3cb062940077a7a1dbfc93d55be6ef3d4f605883b42f71970381662&#34;
    ]
  },
  &#34;history&#34;: [
    {
      &#34;created&#34;: &#34;2020-11-17T20:21:17.570073346Z&#34;,
      &#34;created_by&#34;: &#34;/bin/sh -c #(nop) ADD file:d2abb0e4e7ac1773741f51f57d3a0b8ffc7907348842d773f8c341ba17f856d5 in / &#34;
    },
    {
      &#34;created&#34;: &#34;2020-11-17T20:21:17.865210281Z&#34;,
      &#34;created_by&#34;: &#34;/bin/sh -c #(nop)  CMD [\&#34;bash\&#34;]&#34;,
      &#34;empty_layer&#34;: true
    },
    {
      &#34;created&#34;: &#34;2020-11-18T15:21:22.717162717Z&#34;,
      &#34;created_by&#34;: &#34;/bin/sh -c set -eux; \tapt-get update; \tapt-get install -y --no-install-recommends \t\tbzip2 \t\tca-certificates \t\tlibffi-dev \t\tlibgmp-dev \t\tlibssl-dev \t\tlibyaml-dev \t\tprocps \t\tzlib1g-dev \t; \trm -rf /var/lib/apt/lists/*&#34;
    },
    {
      &#34;created&#34;: &#34;2020-11-18T15:21:23.811888513Z&#34;,
      &#34;created_by&#34;: &#34;/bin/sh -c set -eux; \tmkdir -p /usr/local/etc; \t{ \t\techo &#39;install: --no-document&#39;; \t\techo &#39;update: --no-document&#39;; \t} &gt;&gt; /usr/local/etc/gemrc&#34;
    },
    {
      &#34;created&#34;: &#34;2020-11-18T15:21:24.004412503Z&#34;,
      &#34;created_by&#34;: &#34;/bin/sh -c #(nop)  ENV LANG=C.UTF-8&#34;,
      &#34;empty_layer&#34;: true
    },
    {
      &#34;created&#34;: &#34;2020-11-18T15:30:41.383881949Z&#34;,
      &#34;created_by&#34;: &#34;/bin/sh -c #(nop)  ENV RUBY_MAJOR=2.7&#34;,
      &#34;empty_layer&#34;: true
    },
    {
      &#34;created&#34;: &#34;2020-11-18T15:30:41.629378277Z&#34;,
      &#34;created_by&#34;: &#34;/bin/sh -c #(nop)  ENV RUBY_VERSION=2.7.2&#34;,
      &#34;empty_layer&#34;: true
    },
    {
      &#34;created&#34;: &#34;2020-11-18T15:30:41.868222399Z&#34;,
      &#34;created_by&#34;: &#34;/bin/sh -c #(nop)  ENV RUBY_DOWNLOAD_SHA256=1b95ab193cc8f5b5e59d2686cb3d5dcf1ddf2a86cb6950e0b4bdaae5040ec0d6&#34;,
      &#34;empty_layer&#34;: true
    },
    {
      &#34;created&#34;: &#34;2020-11-18T15:35:11.770005784Z&#34;,
      &#34;created_by&#34;: &#34;/bin/sh -c set -eux; \t\tsavedAptMark=\&#34;$(apt-mark showmanual)\&#34;; \tapt-get update; \tapt-get install -y --no-install-recommends \t\tautoconf \t\tbison \t\tdpkg-dev \t\tgcc \t\tlibbz2-dev \t\tlibgdbm-compat-dev \t\tlibgdbm-dev \t\tlibglib2.0-dev \t\tlibncurses-dev \t\tlibreadline-dev \t\tlibxml2-dev \t\tlibxslt-dev \t\tmake \t\truby \t\twget \t\txz-utils \t; \trm -rf /var/lib/apt/lists/*; \t\twget -O ruby.tar.xz \&#34;https://cache.ruby-lang.org/pub/ruby/${RUBY_MAJOR%-rc}/ruby-$RUBY_VERSION.tar.xz\&#34;; \techo \&#34;$RUBY_DOWNLOAD_SHA256 *ruby.tar.xz\&#34; | sha256sum --check --strict; \t\tmkdir -p /usr/src/ruby; \ttar -xJf ruby.tar.xz -C /usr/src/ruby --strip-components=1; \trm ruby.tar.xz; \t\tcd /usr/src/ruby; \t\t{ \t\techo &#39;#define ENABLE_PATH_CHECK 0&#39;; \t\techo; \t\tcat file.c; \t} &gt; file.c.new; \tmv file.c.new file.c; \t\tautoconf; \tgnuArch=\&#34;$(dpkg-architecture --query DEB_BUILD_GNU_TYPE)\&#34;; \t./configure \t\t--build=\&#34;$gnuArch\&#34; \t\t--disable-install-doc \t\t--enable-shared \t; \tmake -j \&#34;$(nproc)\&#34;; \tmake install; \t\tapt-mark auto &#39;.*&#39; &gt; /dev/null; \tapt-mark manual $savedAptMark &gt; /dev/null; \tfind /usr/local -type f -executable -not \\( -name &#39;*tkinter*&#39; \\) -exec ldd &#39;{}&#39; &#39;;&#39; \t\t| awk &#39;/=&gt;/ { print $(NF-1) }&#39; \t\t| sort -u \t\t| xargs -r dpkg-query --search \t\t| cut -d: -f1 \t\t| sort -u \t\t| xargs -r apt-mark manual \t; \tapt-get purge -y --auto-remove -o APT::AutoRemove::RecommendsImportant=false; \t\tcd /; \trm -r /usr/src/ruby; \t! dpkg -l | grep -i ruby; \t[ \&#34;$(command -v ruby)\&#34; = &#39;/usr/local/bin/ruby&#39; ]; \truby --version; \tgem --version; \tbundle --version&#34;
    },
    {
      &#34;created&#34;: &#34;2020-11-18T15:35:12.227711802Z&#34;,
      &#34;created_by&#34;: &#34;/bin/sh -c #(nop)  ENV GEM_HOME=/usr/local/bundle&#34;,
      &#34;empty_layer&#34;: true
    },
    {
      &#34;created&#34;: &#34;2020-11-18T15:35:12.563337139Z&#34;,
      &#34;created_by&#34;: &#34;/bin/sh -c #(nop)  ENV BUNDLE_SILENCE_ROOT_WARNING=1 BUNDLE_APP_CONFIG=/usr/local/bundle&#34;,
      &#34;empty_layer&#34;: true
    },
    {
      &#34;created&#34;: &#34;2020-11-18T15:35:12.907595531Z&#34;,
      &#34;created_by&#34;: &#34;/bin/sh -c #(nop)  ENV PATH=/usr/local/bundle/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&#34;,
      &#34;empty_layer&#34;: true
    },
    {
      &#34;created&#34;: &#34;2020-11-18T15:35:14.977063521Z&#34;,
      &#34;created_by&#34;: &#34;/bin/sh -c mkdir -p \&#34;$GEM_HOME\&#34; &amp;&amp; chmod 777 \&#34;$GEM_HOME\&#34;&#34;
    },
    {
      &#34;created&#34;: &#34;2020-11-18T15:35:15.373100656Z&#34;,
      &#34;created_by&#34;: &#34;/bin/sh -c #(nop)  CMD [\&#34;irb\&#34;]&#34;,
      &#34;empty_layer&#34;: true
    }
  ]
}
</code></pre><p><code>layers</code> は <a href=https://github.com/opencontainers/image-spec/blob/v1.0.1/layer.md>Filesystem Layer</a> を表しています。<code>tar+gzip</code> という mediaType の suffix は「gzip 圧縮された tar archive」を表しています。試しに、最も root にあった <code>sha256:852e50cd189dfeb54d97680d9fa6bed21a6d7d18cfb56d6abfe2de9d7f173795</code> の中身を見てみます。</p><pre tabindex=0><code>vagrant@vagrant:~/oci-playground/ruby-oci$ mkdir rootfs
vagrant@vagrant:~/oci-playground/ruby-oci$ tar xvzf blobs/sha256/852e50cd189dfeb54d97680d9fa6bed21a6d7d18cfb56d6abfe2de9d7f173795 -C rootfs/
.
.
.
</code></pre><p>上記コマンドで、rootfs directory 以下に圧縮されていた中身が展開されます（注: <code>tar: bin/uncompress: Cannot hard link to ‘bin/gunzip’: Operation not permitted</code> など一部の file について error は出ていて、そのせいで <code>tar: Exiting with failure status due to previous errors</code> という失敗 message も出てしまいましたが、それはここでは無視します）。</p><p><code>rootfs</code> の中身を見てみると、以下のようにいくつかの directyory が並んでいます。</p><pre tabindex=0><code>vagrant@vagrant:~/oci-playground/ruby-oci$ ls rootfs/
bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
</code></pre><p>試しに変換前の <code>ruby:2.7.2-slim</code> docker image を利用して container を起動してみると、root directory の中身がそっくりであることが確認できます。</p><pre tabindex=0><code>$ docker run -it ruby:2.7.2-slim bash
root@f6be3c7c619d:/# ls /
bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
</code></pre><p>実は、これらの layer が「どう apply されるのか」は <a href=https://github.com/opencontainers/image-spec/blob/v1.0.1/layer.md#applying-changesets>Image Layer Filesystem Changeset の Applying Changesets というセクション</a> の中で以下のように明確に定義されています。ざっくり言えば「layer の上から順に tar archive を展開したようなもの」になります。
「file や directory の削除」は <a href=https://github.com/opencontainers/image-spec/blob/v1.0.1/layer.md#whiteouts>Whiteouts</a> と呼ばれる特別な仕様で表現されますが、特別に注意を払う必要があるのはそれくらいのようです。</p><blockquote><h3 id=applying-changesets>Applying Changesets<a hidden class=anchor aria-hidden=true href=#applying-changesets>#</a></h3><ul><li>Layer Changesets of <a href=https://github.com/opencontainers/image-spec/blob/v1.0.1/media-types.md>media type</a> application/vnd.oci.image.layer.v1.tar are applied, rather than simply extracted as tar archives.</li><li>Applying a layer changeset requires special consideration for the <a href=https://github.com/opencontainers/image-spec/blob/v1.0.1/layer.md#whiteouts>whiteout</a> files.</li><li>In the absence of any <a href=https://github.com/opencontainers/image-spec/blob/v1.0.1/layer.md#whiteouts>whiteout</a> files in a layer changeset, the archive is extracted like a regular tar archive.</li></ul></blockquote><p>cf. <a href=https://github.com/opencontainers/image-spec/blob/v1.0.1/layer.md#applying-changesets>https://github.com/opencontainers/image-spec/blob/v1.0.1/layer.md#applying-changesets</a></p><p>ということで、OCI image の中身に目を通してみました。「Conatainer を走らせるために必要な情報（= 実行時のメタデータ + Layer 化された filesystem の情報）」が格納されてることがわかったかと思います。</p><h2 id=container-registry-との通信内容を見てみる>Container Registry との通信内容を見てみる<a hidden class=anchor aria-hidden=true href=#container-registry-との通信内容を見てみる>#</a></h2><p>ここまでで、「Container Image の内容」については把握できました。次に、「Container Registry から Container Image をどのように pull しているのか」を調べてみましょう。</p><p>現在、各種 Container Registry は Docker 社が公開している <a href=https://docs.docker.com/registry/spec/api/>Docker Registry HTTP API V2</a> と呼ばれる仕様に従う形で Container Image の Pull を出来るようにしています。実は、「Container Image の Pull」にあたる操作はただの HTTP request であるため、<code>$ curl</code> を利用して実行する事ができます。ここでは、実際に <code>$ curl</code> で request してみることで、Container Registry との通信内容を見てみる事にしましょう。</p><p>なお、自分が試した範囲では、どの Container Image も <a href=https://github.com/opencontainers/image-spec/tree/v1.0.1>OCI Image Format</a> ではなく <a href=https://docs.docker.com/registry/spec/manifest-v2-2/>Docker Image Manifest V 2, Schema 2</a> に従う形の response を返してきました。ただ、OCI Image Format と Docker Image V2.2 は一部の mediaType 名を除いてほぼ同一なので、先ほど眺めた内容は理解に役立つはずです。</p><p>さて、実際に curl で request を送ってみましょう。対象 Container Image は何でも良いのですが、ここでは <a href=https://github.com/GoogleContainerTools/base-images-docker>https://github.com/GoogleContainerTools/base-images-docker</a> に記載されてる Debian の Container Image である <code>gcr.io/google-appengine/debian9</code> を対象にしてみます。</p><p>まず、以下のように Container Registry の Authentication に必要な Token を取得します。この時、「<code>google-appengine/debian9</code> の pull」という形で <code>scope</code> を指定しておきます。</p><pre tabindex=0><code>$ export TOKEN=$(curl &#34;https://gcr.io/v2/token?service=gcr.io&amp;scope=repository:google-appengine/debian9:pull&#34; | jq -r &#39;.token&#39;)
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   453    0   453    0     0   1088      0 --:--:-- --:--:-- --:--:--  1088
</code></pre><p>次に、<code>https://gcr.io/v2/&lt;name>/manifests/&lt;reference></code> へ先ほど取得した Token 付きで <code>GET</code> request を送ります。こうすると、<a href=https://docs.docker.com/registry/spec/manifest-v2-2/>Docker Image V2.2</a> における manifest file が取得できます。</p><pre tabindex=0><code>$ curl -H &#34;Authorization: Bearer ${TOKEN}&#34; https://gcr.io/v2/google-appengine/debian9/manifests/latest | jq .
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   528  100   528    0     0    469      0  0:00:01  0:00:01 --:--:--   469
{
  &#34;schemaVersion&#34;: 2,
  &#34;mediaType&#34;: &#34;application/vnd.docker.distribution.manifest.v2+json&#34;,
  &#34;config&#34;: {
    &#34;mediaType&#34;: &#34;application/vnd.docker.container.image.v1+json&#34;,
    &#34;size&#34;: 463,
    &#34;digest&#34;: &#34;sha256:18c47921b263ac67af3d654e3b485c998d1e6bab56edc5a15b6b7a8fad3ac18a&#34;
  },
  &#34;layers&#34;: [
    {
      &#34;mediaType&#34;: &#34;application/vnd.docker.image.rootfs.diff.tar.gzip&#34;,
      &#34;size&#34;: 47965538,
      &#34;digest&#34;: &#34;sha256:faa9d9046d25e5fd30ac4444c7b6c30a1a6fff7c461410547156aed2001668a1&#34;
    }
  ]
}
</code></pre><p>まず、<code>config</code> の中身を見てみましょう。</p><p>digest を利用して参照を辿る際は <code>https://gcr.io/v2/&lt;name>/blobs/&lt;digest></code> へ request すれば良いです。実際に request してみると、以下のような response が返ってきます。先ほど OCI Image の中身を見てみた時と同様に、Container 実行に必要なメタデータが格納されていることが分かります。</p><pre tabindex=0><code>$ curl -L -H &#34;Authorization: Bearer ${TOKEN}&#34; https://gcr.io/v2/google-appengine/debian9/blobs/sha256:18c47921b263ac67af3d654e3b485c998d1e6bab56edc5a15b6b7a8fad3ac18a | jq .
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100    13    0    13    0     0     23      0 --:--:-- --:--:-- --:--:--    23
100   463  100   463    0     0    750      0 --:--:-- --:--:-- --:--:--   750
{
  &#34;architecture&#34;: &#34;amd64&#34;,
  &#34;author&#34;: &#34;Bazel&#34;,
  &#34;created&#34;: &#34;1970-01-01T00:00:00Z&#34;,
  &#34;history&#34;: [
    {
      &#34;author&#34;: &#34;Bazel&#34;,
      &#34;created&#34;: &#34;1970-01-01T00:00:00Z&#34;,
      &#34;created_by&#34;: &#34;bazel build ...&#34;
    }
  ],
  &#34;os&#34;: &#34;linux&#34;,
  &#34;rootfs&#34;: {
    &#34;type&#34;: &#34;layers&#34;,
    &#34;diff_ids&#34;: [
      &#34;sha256:0a3dcb016bd8a852985044291de00ad6a6b94dcb0eac01b34b56afed409b9999&#34;
    ]
  },
  &#34;config&#34;: {
    &#34;Cmd&#34;: [
      &#34;/bin/sh&#34;,
      &#34;-c&#34;,
      &#34;/bin/bash&#34;
    ],
    &#34;Env&#34;: [
      &#34;DEBIAN_FRONTEND=noninteractive&#34;,
      &#34;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&#34;,
      &#34;PORT=8080&#34;
    ]
  }
}
</code></pre><p>なお、注意点として、どうやら GCR は <code>https://gcr.io/v2/&lt;name>/blobs/&lt;digest></code> への request では Google Cloud Storage への redirect response を返すようです。<code>-L</code> オプションを付けない場合は以下のような結果になることには留意してください。</p><pre tabindex=0><code>$ curl --include -H &#34;Authorization: Bearer ${TOKEN}&#34; https://gcr.io/v2/google-appengine/debian9/blobs/sha256:18c47921b263ac67af3d654e3b485c998d1e6bab56edc5a15b6b7a8fad3ac18a
HTTP/2 302
docker-distribution-api-version: registry/2.0
location: https://storage.googleapis.com/artifacts.google-appengine.appspot.com/containers/images/sha256:18c47921b263ac67af3d654e3b485c998d1e6bab56edc5a15b6b7a8fad3ac18a
content-type: application/json
date: Wed, 09 Dec 2020 13:38:51 GMT
server: Docker Registry
cache-control: private
x-xss-protection: 0
x-frame-options: SAMEORIGIN
alt-svc: h3-29=&#34;:443&#34;; ma=2592000,h3-T051=&#34;:443&#34;; ma=2592000,h3-Q050=&#34;:443&#34;; ma=2592000,h3-Q046=&#34;:443&#34;; ma=2592000,h3-Q043=&#34;:443&#34;; ma=2592000,quic=&#34;:443&#34;; ma=2592000; v=&#34;46,43&#34;
accept-ranges: none
vary: Accept-Encoding

{&#34;errors&#34;:[]}%
</code></pre><p>上記では config の取得を行いましたが、Layer （mediaType: <code>application/vnd.docker.image.rootfs.diff.tar.gzip</code> のデータ）についても同様に<code>https://gcr.io/v2/&lt;name>/blobs/&lt;digest></code> への request によって取得する事ができます。先ほどと同様に、<code>tar</code> コマンドで展開すると container 実行に利用される file を取得することが出来ます。</p><pre tabindex=0><code>$ curl -L -H &#34;Authorization: Bearer ${TOKEN}&#34; https://gcr.io/v2/google-appengine/debian9/blobs/sha256:faa9d9046d25e5fd30ac4444c7b6c30a1a6fff7c461410547156aed2001668a1 --output /tmp/faa9d9046d25e5fd30ac4444c7b6c30a1a6fff7c461410547156aed2001668a1
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100    13    0    13    0     0     28      0 --:--:-- --:--:-- --:--:--    28
100 45.7M  100 45.7M    0     0  13.6M      0  0:00:03  0:00:03 --:--:-- 20.1M

$ ls -la /tmp/faa9d9046d25e5fd30ac4444c7b6c30a1a6fff7c461410547156aed2001668a1
-rw-r--r--  1 minami  wheel  47965538 Dec  9 23:48 /tmp/faa9d9046d25e5fd30ac4444c7b6c30a1a6fff7c461410547156aed2001668a1

$ mkdir /tmp/rootfs
$ tar xvzf /tmp/faa9d9046d25e5fd30ac4444c7b6c30a1a6fff7c461410547156aed2001668a1 -C /tmp/rootfs/
$ ls /tmp/rootfs
bin   boot  dev   etc   home  lib   lib64 media mnt   opt   proc  root  run   sbin  srv   sys   tmp   usr   var
</code></pre><p>という事で、Container Registry との通信について、特に「Container Image の Pull」に絞って通信内容を見てみました。<a href=https://docs.docker.com/registry/spec/manifest-v2-2/>Docker Image V2.2</a> をベースにした通信である事、特に config や layer などがそれぞれの単位で通信できることなどが分かったかと思います。より詳しい内容が気になる場合は、<a href=https://docs.docker.com/registry/spec/api/>Docker Registry HTTP API V2</a> を参照してみてください。</p><p>なお、「Container Image 全てをまとめた file を一括でダウンロードしないのは何故なのか？」という疑問についてですが、これは自分の理解では「Layer Cache を効かせた形での Image Pull を実現するため」だと捉えています。Layer のデータは巨大であるため最低限の通信で済ませたいというのが大前提にあり、そのために「コンテンツの中身を反映した digest 値を用いて、Layer ごとに通信する」という振る舞いになっているのだと思われます。</p><h2 id=まとめ>まとめ<a hidden class=anchor aria-hidden=true href=#まとめ>#</a></h2><p>OCI image を実際に作成して眺めて見ることで、Container Image について理解を深めました。また、<code>curl</code> で Container Registry との通信を行うことで、Container Registry との通信内容についても理解を深める事が出来ました。</p><p>ドキュメントを読むだけだとどうしても理解が曖昧になってしまいがちですが、実際に手を動かす事で具体的な動作をイメージ出来るようになります。このブログ自体は自分の理解のために試したことをまとめたものですが、誰か他の人にとっても理解を助けるものになっていれば幸いです。</p><p>なお、今回は Container Image + Container Registry 編でしたが、後日 Container Runtime についても「手を動かして調べた内容」についてまとめたいと思っています。特に、「Container Image から Container Runtime が利用する <a href=https://github.com/opencontainers/runtime-spec/blob/v1.0.2/bundle.md>Filesystem Bundle</a> への Conversion」や、「runc などの low-level Container Runtime の動作」、「containerd や CRI-O などの high-level Container Runtime の動作」について試したことをまとめる予定です。</p><h2 id=補足-vagrant-での実験環境>補足: Vagrant での実験環境<a hidden class=anchor aria-hidden=true href=#補足-vagrant-での実験環境>#</a></h2><p>以下のような Vagrantfile を使ってます。ubuntu-20.04 を使ってます。</p><pre tabindex=0><code># -*- mode: ruby -*-
# vi: set ft=ruby :

VAGRANTFILE_API_VERSION = &#34;2&#34;

Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
  config.vm.box = &#34;bento/ubuntu-20.04&#34;
end
</code></pre><h2 id=参考文献>参考文献<a hidden class=anchor aria-hidden=true href=#参考文献>#</a></h2><p>以下のブログは、ツールやコマンド、内容において大幅に参考にさせて頂きました。ありがとうございました。</p><ul><li><a href=https://blog.unasuke.com/2018/read-oci-image-spec-v101/>https://blog.unasuke.com/2018/read-oci-image-spec-v101/</a></li><li><a href=https://knqyf263.hatenablog.com/entry/2019/11/29/052818>https://knqyf263.hatenablog.com/entry/2019/11/29/052818</a></li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://www.south37.net/posts/20201211-container-3/><span class=title>« Prev</span><br><span>手を動かして学ぶコンテナ標準 - Container Runtime 編</span></a>
<a class=next href=https://www.south37.net/posts/20201207-container-1/><span class=title>Next »</span><br><span>コンテナ標準化の現状と Kubernetes との関係性について</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 手を動かして学ぶコンテナ標準 - Container Image と Container Registry 編 on twitter" href="https://twitter.com/intent/tweet/?text=%e6%89%8b%e3%82%92%e5%8b%95%e3%81%8b%e3%81%97%e3%81%a6%e5%ad%a6%e3%81%b6%e3%82%b3%e3%83%b3%e3%83%86%e3%83%8a%e6%a8%99%e6%ba%96%20-%20Container%20Image%20%e3%81%a8%20Container%20Registry%20%e7%b7%a8&amp;url=https%3a%2f%2fwww.south37.net%2fposts%2f20201210-container-2%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 手を動かして学ぶコンテナ標準 - Container Image と Container Registry 編 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwww.south37.net%2fposts%2f20201210-container-2%2f&amp;title=%e6%89%8b%e3%82%92%e5%8b%95%e3%81%8b%e3%81%97%e3%81%a6%e5%ad%a6%e3%81%b6%e3%82%b3%e3%83%b3%e3%83%86%e3%83%8a%e6%a8%99%e6%ba%96%20-%20Container%20Image%20%e3%81%a8%20Container%20Registry%20%e7%b7%a8&amp;summary=%e6%89%8b%e3%82%92%e5%8b%95%e3%81%8b%e3%81%97%e3%81%a6%e5%ad%a6%e3%81%b6%e3%82%b3%e3%83%b3%e3%83%86%e3%83%8a%e6%a8%99%e6%ba%96%20-%20Container%20Image%20%e3%81%a8%20Container%20Registry%20%e7%b7%a8&amp;source=https%3a%2f%2fwww.south37.net%2fposts%2f20201210-container-2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 手を動かして学ぶコンテナ標準 - Container Image と Container Registry 編 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.south37.net%2fposts%2f20201210-container-2%2f&title=%e6%89%8b%e3%82%92%e5%8b%95%e3%81%8b%e3%81%97%e3%81%a6%e5%ad%a6%e3%81%b6%e3%82%b3%e3%83%b3%e3%83%86%e3%83%8a%e6%a8%99%e6%ba%96%20-%20Container%20Image%20%e3%81%a8%20Container%20Registry%20%e7%b7%a8"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 手を動かして学ぶコンテナ標準 - Container Image と Container Registry 編 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.south37.net%2fposts%2f20201210-container-2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 手を動かして学ぶコンテナ標準 - Container Image と Container Registry 編 on whatsapp" href="https://api.whatsapp.com/send?text=%e6%89%8b%e3%82%92%e5%8b%95%e3%81%8b%e3%81%97%e3%81%a6%e5%ad%a6%e3%81%b6%e3%82%b3%e3%83%b3%e3%83%86%e3%83%8a%e6%a8%99%e6%ba%96%20-%20Container%20Image%20%e3%81%a8%20Container%20Registry%20%e7%b7%a8%20-%20https%3a%2f%2fwww.south37.net%2fposts%2f20201210-container-2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 手を動かして学ぶコンテナ標準 - Container Image と Container Registry 編 on telegram" href="https://telegram.me/share/url?text=%e6%89%8b%e3%82%92%e5%8b%95%e3%81%8b%e3%81%97%e3%81%a6%e5%ad%a6%e3%81%b6%e3%82%b3%e3%83%b3%e3%83%86%e3%83%8a%e6%a8%99%e6%ba%96%20-%20Container%20Image%20%e3%81%a8%20Container%20Registry%20%e7%b7%a8&amp;url=https%3a%2f%2fwww.south37.net%2fposts%2f20201210-container-2%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://www.south37.net/>South37's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>