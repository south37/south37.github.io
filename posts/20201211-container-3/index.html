<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>手を動かして学ぶコンテナ標準 - Container Runtime 編 | South37's Blog</title><meta name=keywords content><meta name=description content="コンテナ標準化の現状と Kubernetes の立ち位置について というブログではコンテナ標準の現状についてまとめてみました。
また、手を動かして学ぶコンテナ標準 - Container Image と Container Registry 編 というブログでは Container Image と Container Registry について手を動かして学んでみました。
このブログでは、runc, containerd などの Container Runtime について、実際に手を動かして学んでみたいと思います。
なお、前回のブログ 同様、基本的にこのブログ内のコマンドは Linux で実行するものとします（自分は MacOS で Vagrant で Ubuntu VM を立てて実験してます）。
runc を動かしてみる runc は Low-Level Container Runtime と呼ばれるもので、OCI Runtime Specification に準拠した CLI tool となっています。実際に runc を動かしてみることで、Container Runtime に対して理解を深めてみましょう。
まず runc の install ですが、自分が試している ubuntu-20.04 では apt で install することができます。
vagrant@vagrant:~$ sudo apt update -y vagrant@vagrant:~$ sudo apt install -y runc vagrant@vagrant:~$ which runc /usr/sbin/runc help を見てみると以下のような内容になっていて、container を操作するために必要な各種 subcommand が存在することがわかります。実は、これらの subcommand によって OCI Runtime Specification の Runtime and Lifecycle で定義された「Operations」 の機能が提供されています。ただし、見比べてみると分かりますが runc 自体はよりリッチな機能を提供しているようです。"><meta name=author content="Nao Minami"><link rel=canonical href=https://www.south37.net/posts/20201211-container-3/><link crossorigin=anonymous href=/assets/css/stylesheet.b183800e2cfbb62c3bce2b2ba56cdb2dd33af76c75cf4550173d5dfebd7c68a6.css integrity="sha256-sYOADiz7tiw7zisrpWzbLdM692x1z0VQFz1d/r18aKY=" rel="preload stylesheet" as=style><link rel=icon href=https://www.south37.net/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.south37.net/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.south37.net/favicon-32x32.png><link rel=apple-touch-icon href=https://www.south37.net/apple-touch-icon.png><link rel=mask-icon href=https://www.south37.net/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="手を動かして学ぶコンテナ標準 - Container Runtime 編"><meta property="og:description" content="コンテナ標準化の現状と Kubernetes の立ち位置について というブログではコンテナ標準の現状についてまとめてみました。
また、手を動かして学ぶコンテナ標準 - Container Image と Container Registry 編 というブログでは Container Image と Container Registry について手を動かして学んでみました。
このブログでは、runc, containerd などの Container Runtime について、実際に手を動かして学んでみたいと思います。
なお、前回のブログ 同様、基本的にこのブログ内のコマンドは Linux で実行するものとします（自分は MacOS で Vagrant で Ubuntu VM を立てて実験してます）。
runc を動かしてみる runc は Low-Level Container Runtime と呼ばれるもので、OCI Runtime Specification に準拠した CLI tool となっています。実際に runc を動かしてみることで、Container Runtime に対して理解を深めてみましょう。
まず runc の install ですが、自分が試している ubuntu-20.04 では apt で install することができます。
vagrant@vagrant:~$ sudo apt update -y vagrant@vagrant:~$ sudo apt install -y runc vagrant@vagrant:~$ which runc /usr/sbin/runc help を見てみると以下のような内容になっていて、container を操作するために必要な各種 subcommand が存在することがわかります。実は、これらの subcommand によって OCI Runtime Specification の Runtime and Lifecycle で定義された「Operations」 の機能が提供されています。ただし、見比べてみると分かりますが runc 自体はよりリッチな機能を提供しているようです。"><meta property="og:type" content="article"><meta property="og:url" content="https://www.south37.net/posts/20201211-container-3/"><meta property="og:image" content="https://www.south37.net/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-12-11T00:00:00+09:00"><meta property="article:modified_time" content="2020-12-11T00:00:00+09:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.south37.net/papermod-cover.png"><meta name=twitter:title content="手を動かして学ぶコンテナ標準 - Container Runtime 編"><meta name=twitter:description content="コンテナ標準化の現状と Kubernetes の立ち位置について というブログではコンテナ標準の現状についてまとめてみました。
また、手を動かして学ぶコンテナ標準 - Container Image と Container Registry 編 というブログでは Container Image と Container Registry について手を動かして学んでみました。
このブログでは、runc, containerd などの Container Runtime について、実際に手を動かして学んでみたいと思います。
なお、前回のブログ 同様、基本的にこのブログ内のコマンドは Linux で実行するものとします（自分は MacOS で Vagrant で Ubuntu VM を立てて実験してます）。
runc を動かしてみる runc は Low-Level Container Runtime と呼ばれるもので、OCI Runtime Specification に準拠した CLI tool となっています。実際に runc を動かしてみることで、Container Runtime に対して理解を深めてみましょう。
まず runc の install ですが、自分が試している ubuntu-20.04 では apt で install することができます。
vagrant@vagrant:~$ sudo apt update -y vagrant@vagrant:~$ sudo apt install -y runc vagrant@vagrant:~$ which runc /usr/sbin/runc help を見てみると以下のような内容になっていて、container を操作するために必要な各種 subcommand が存在することがわかります。実は、これらの subcommand によって OCI Runtime Specification の Runtime and Lifecycle で定義された「Operations」 の機能が提供されています。ただし、見比べてみると分かりますが runc 自体はよりリッチな機能を提供しているようです。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.south37.net/posts/"},{"@type":"ListItem","position":2,"name":"手を動かして学ぶコンテナ標準 - Container Runtime 編","item":"https://www.south37.net/posts/20201211-container-3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"手を動かして学ぶコンテナ標準 - Container Runtime 編","name":"手を動かして学ぶコンテナ標準 - Container Runtime 編","description":"コンテナ標準化の現状と Kubernetes の立ち位置について というブログではコンテナ標準の現状についてまとめてみました。\nまた、手を動かして学ぶコンテナ標準 - Container Image と Container Registry 編 というブログでは Container Image と Container Registry について手を動かして学んでみました。\nこのブログでは、runc, containerd などの Container Runtime について、実際に手を動かして学んでみたいと思います。\nなお、前回のブログ 同様、基本的にこのブログ内のコマンドは Linux で実行するものとします（自分は MacOS で Vagrant で Ubuntu VM を立てて実験してます）。\nrunc を動かしてみる runc は Low-Level Container Runtime と呼ばれるもので、OCI Runtime Specification に準拠した CLI tool となっています。実際に runc を動かしてみることで、Container Runtime に対して理解を深めてみましょう。\nまず runc の install ですが、自分が試している ubuntu-20.04 では apt で install することができます。\nvagrant@vagrant:~$ sudo apt update -y vagrant@vagrant:~$ sudo apt install -y runc vagrant@vagrant:~$ which runc /usr/sbin/runc help を見てみると以下のような内容になっていて、container を操作するために必要な各種 subcommand が存在することがわかります。実は、これらの subcommand によって OCI Runtime Specification の Runtime and Lifecycle で定義された「Operations」 の機能が提供されています。ただし、見比べてみると分かりますが runc 自体はよりリッチな機能を提供しているようです。","keywords":[],"articleBody":"コンテナ標準化の現状と Kubernetes の立ち位置について というブログではコンテナ標準の現状についてまとめてみました。\nまた、手を動かして学ぶコンテナ標準 - Container Image と Container Registry 編 というブログでは Container Image と Container Registry について手を動かして学んでみました。\nこのブログでは、runc, containerd などの Container Runtime について、実際に手を動かして学んでみたいと思います。\nなお、前回のブログ 同様、基本的にこのブログ内のコマンドは Linux で実行するものとします（自分は MacOS で Vagrant で Ubuntu VM を立てて実験してます）。\nrunc を動かしてみる runc は Low-Level Container Runtime と呼ばれるもので、OCI Runtime Specification に準拠した CLI tool となっています。実際に runc を動かしてみることで、Container Runtime に対して理解を深めてみましょう。\nまず runc の install ですが、自分が試している ubuntu-20.04 では apt で install することができます。\nvagrant@vagrant:~$ sudo apt update -y vagrant@vagrant:~$ sudo apt install -y runc vagrant@vagrant:~$ which runc /usr/sbin/runc help を見てみると以下のような内容になっていて、container を操作するために必要な各種 subcommand が存在することがわかります。実は、これらの subcommand によって OCI Runtime Specification の Runtime and Lifecycle で定義された「Operations」 の機能が提供されています。ただし、見比べてみると分かりますが runc 自体はよりリッチな機能を提供しているようです。\nvagrant@vagrant:~$ runc --help NAME: runc - Open Container Initiative runtime runc is a command line client for running applications packaged according to the Open Container Initiative (OCI) format and is a compliant implementation of the Open Container Initiative specification. runc integrates well with existing process supervisors to provide a production container runtime environment for applications. It can be used with your existing process monitoring tools and the container will be spawned as a direct child of the process supervisor. Containers are configured using bundles. A bundle for a container is a directory that includes a specification file named \"config.json\" and a root filesystem. The root filesystem contains the contents of the container. To start a new instance of a container: # runc run [ -b bundle ] Where \"\" is your name for the instance of the container that you are starting. The name you provide for the container instance must be unique on your host. Providing the bundle directory using \"-b\" is optional. The default value for \"bundle\" is the current directory. USAGE: runc [global options] command [command options] [arguments...] VERSION: spec: 1.0.1-dev COMMANDS: checkpoint checkpoint a running container create create a container delete delete any resources held by the container often used with detached container events display container events such as OOM notifications, cpu, memory, and IO usage statistics exec execute new process inside the container init initialize the namespaces and launch the process (do not call it outside of runc) kill kill sends the specified signal (default: SIGTERM) to the container's init process list lists containers started by runc with the given root pause pause suspends all processes inside the container ps ps displays the processes running inside a container restore restore a container from a previous checkpoint resume resumes all processes that have been previously paused run create and run a container spec create a new specification file start executes the user defined process in a created container state output the state of a container update update container resource constraints help, h Shows a list of commands or help for one command GLOBAL OPTIONS: --debug enable debug output for logging --log value set the log file path where internal debug information is written --log-format value set the format used by logs ('text' (default), or 'json') (default: \"text\") --root value root directory for storage of container state (this should be located in tmpfs) (default: \"/run/user/1000/runc\") --criu value path to the criu binary used for checkpoint and restore (default: \"criu\") --systemd-cgroup enable systemd cgroup support, expects cgroupsPath to be of form \"slice:prefix:name\" for e.g. \"system.slice:runc:434234\" --rootless value ignore cgroup permission errors ('true', 'false', or 'auto') (default: \"auto\") --help, -h show help --version, -v print the version 実際に runc を利用して container を起動してみましょう。runc の README の Using runc というセクションがぴったりの題材なので、これを参考にしてみます。\nOCI Runtime Speicification の内容を見てもらうと分かるのですが、runc のような Low-Level Container Runtime は Filesystem Bundle と呼ばれる「Container を起動するのに利用される configuration file と、container にとっての root filesystem となる directory の組み合わせ」を必要とします。まずはこの Filesystem Bundle を用意します。\nFilesystem Bundle は config.json と呼ばれる configuration file と、その config.json の中の root.path で path を指定される 「container の root filesystem となる directory」から構成されます。それぞれ順番に作成していきます。\nまずは Filesystem Bundle を格納する directory として mycontainer という directory を作っておきます。\nvagrant@vagrant:~$ mkdir mycontainer vagrant@vagrant:~$ cd mycontainer/ 次に、config.json についてですが、 $ runc spec を実行すると自動でデフォルト設定の config.json が作成されます。今回はこれを使うことにしましょう。\nvagrant@vagrant:~/mycontainer$ runc spec vagrant@vagrant:~/mycontainer$ ls config.json デフォルト設定の config.json は以下のような内容になっています。実行時のコマンドや環境変数、root.path などに加えて、namespace や volume mount, capability の設定なども記載されています。\nvagrant@vagrant:~/mycontainer$ cat config.json { \"ociVersion\": \"1.0.1-dev\", \"process\": { \"terminal\": true, \"user\": { \"uid\": 0, \"gid\": 0 }, \"args\": [ \"sh\" ], \"env\": [ \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", \"TERM=xterm\" ], \"cwd\": \"/\", \"capabilities\": { \"bounding\": [ \"CAP_AUDIT_WRITE\", \"CAP_KILL\", \"CAP_NET_BIND_SERVICE\" ], \"effective\": [ \"CAP_AUDIT_WRITE\", \"CAP_KILL\", \"CAP_NET_BIND_SERVICE\" ], \"inheritable\": [ \"CAP_AUDIT_WRITE\", \"CAP_KILL\", \"CAP_NET_BIND_SERVICE\" ], \"permitted\": [ \"CAP_AUDIT_WRITE\", \"CAP_KILL\", \"CAP_NET_BIND_SERVICE\" ], \"ambient\": [ \"CAP_AUDIT_WRITE\", \"CAP_KILL\", \"CAP_NET_BIND_SERVICE\" ] }, \"rlimits\": [ { \"type\": \"RLIMIT_NOFILE\", \"hard\": 1024, \"soft\": 1024 } ], \"noNewPrivileges\": true }, \"root\": { \"path\": \"rootfs\", \"readonly\": true }, \"hostname\": \"runc\", \"mounts\": [ { \"destination\": \"/proc\", \"type\": \"proc\", \"source\": \"proc\" }, { \"destination\": \"/dev\", \"type\": \"tmpfs\", \"source\": \"tmpfs\", \"options\": [ \"nosuid\", \"strictatime\", \"mode=755\", \"size=65536k\" ] }, { \"destination\": \"/dev/pts\", \"type\": \"devpts\", \"source\": \"devpts\", \"options\": [ \"nosuid\", \"noexec\", \"newinstance\", \"ptmxmode=0666\", \"mode=0620\", \"gid=5\" ] }, { \"destination\": \"/dev/shm\", \"type\": \"tmpfs\", \"source\": \"shm\", \"options\": [ \"nosuid\", \"noexec\", \"nodev\", \"mode=1777\", \"size=65536k\" ] }, { \"destination\": \"/dev/mqueue\", \"type\": \"mqueue\", \"source\": \"mqueue\", \"options\": [ \"nosuid\", \"noexec\", \"nodev\" ] }, { \"destination\": \"/sys\", \"type\": \"sysfs\", \"source\": \"sysfs\", \"options\": [ \"nosuid\", \"noexec\", \"nodev\", \"ro\" ] }, { \"destination\": \"/sys/fs/cgroup\", \"type\": \"cgroup\", \"source\": \"cgroup\", \"options\": [ \"nosuid\", \"noexec\", \"nodev\", \"relatime\", \"ro\" ] } ], \"linux\": { \"resources\": { \"devices\": [ { \"allow\": false, \"access\": \"rwm\" } ] }, \"namespaces\": [ { \"type\": \"pid\" }, { \"type\": \"network\" }, { \"type\": \"ipc\" }, { \"type\": \"uts\" }, { \"type\": \"mount\" } ], \"maskedPaths\": [ \"/proc/acpi\", \"/proc/asound\", \"/proc/kcore\", \"/proc/keys\", \"/proc/latency_stats\", \"/proc/timer_list\", \"/proc/timer_stats\", \"/proc/sched_debug\", \"/sys/firmware\", \"/proc/scsi\" ], \"readonlyPaths\": [ \"/proc/bus\", \"/proc/fs\", \"/proc/irq\", \"/proc/sys\", \"/proc/sysrq-trigger\" ] } 次に、container の root filesystem となる directory を用意します。今回は楽をするために、「$ docker export の機能を利用する」ことにします（自分は vagrant で synced_folder した directory で docker export しました）。原理的には、どんな手段で用意しても良いはずです。\n$ mkdir rootfs $ docker export $(docker create busybox) | tar -C rootfs -xvf - 上記コマンドまで実行が終わると、mycontainer directory の中は以下のような状態になっているはずです。\nvagrant@vagrant:~/mycontainer$ ls config.json rootfs この状態で $ sudo runc run containerid を実行すると、container が起動します。\nvagrant@vagrant:~/oci-playground/runc-playground/mycontainer2$ sudo runc run containerid / # 上記で作成した config.json はデフォルトで「sh コマンドを実行する」という設定になっているので、sh が起動しています。\nそのため、一度 exit してから config.json を例えば「ls を実行するもの」に書き換えると、ls が container 内で実行されます。\nvagrant@vagrant:~/oci-playground/runc-playground/mycontainer2$ vim config.json # ここで以下のように変更 \"args\": [ - \"sh\" + \"ls\" ], vagrant@vagrant:~/oci-playground/runc-playground/mycontainer2$ sudo runc run containerid bin dev etc home proc root sys tmp usr var ということで、runc を利用して無事に container を起動することができました！\nconfig.json + container の root filesystem になる directory という「Filesystem Bundle」を用意さえすれば、「container の起動が簡単に出来る」ということが分かったかと思います。なお、これは OCI Runtime Specification で定められている挙動であるため、この仕様を満たしてさえいれば「runc 以外の Low-Level Container Runtime」においても同様のことができるはずです。\n上記の例では runc run を利用しましたが、その他のオペレーション（create, start, delete など）を利用することでより細かな制御も可能です。詳細が気になる方は、ぜひご自分でも試してみてください。\ncontainerd を動かしてみる Low-Level Container Runtime の runc の次は、High-Level Container Runtime である containerd を動かしてみましょう。runc は「container を起動する」という部分は実行してくれましたが、それ以外の「Container Image の Pull、Container Image から Filesystem Bundle への変換」などはやってくれませんでした。実は、この部分の機能を提供してくれてるのが containerd です。\ncontainerd は、daemon として常駐して、client からの request を受け付けて動作するという振る舞いになっています。containerd の動作のイメージを掴むために、Getting started というページに従って containerd を利用してみましょう。\nまずは、containerd downloads の Installing binaries に従って containerd の binary を download します。そして、その binary を /usr/local/bin など PATH の通った場所に配置します。\nvagrant@vagrant:~$ wget https://github.com/containerd/containerd/releases/download/v1.4.3/containerd-1.4.3-linux-amd64.tar.gz vagrant@vagrant:~$ tar xvf containerd-1.4.3-linux-amd64.tar.gz vagrant@vagrant:~$ sudo mv bin/* /usr/local/bin/ これで、containerd がコマンドとして利用できるようになります。\nvagrant@vagrant:~$ which containerd /usr/local/bin/containerd vagrant@vagrant:~$ containerd --help NAME: containerd - __ _ __ _________ ____ / /_____ _(_)___ ___ _________/ / / ___/ __ \\/ __ \\/ __/ __ `/ / __ \\/ _ \\/ ___/ __ / / /__/ /_/ / / / / /_/ /_/ / / / / / __/ / / /_/ / \\___/\\____/_/ /_/\\__/\\__,_/_/_/ /_/\\___/_/ \\__,_/ high performance container runtime USAGE: containerd [global options] command [command options] [arguments...] VERSION: v1.4.3 DESCRIPTION: containerd is a high performance container runtime whose daemon can be started by using this command. If none of the *config*, *publish*, or *help* commands are specified, the default action of the **containerd** command is to start the containerd daemon in the foreground. A default configuration is used if no TOML configuration is specified or located at the default file location. The *containerd config* command can be used to generate the default configuration for containerd. The output of that command can be used and modified as necessary as a custom configuration. COMMANDS: config information on the containerd config publish binary to publish events to containerd oci-hook provides a base for OCI runtime hooks to allow arguments to be injected. help, h Shows a list of commands or help for one command GLOBAL OPTIONS: --config value, -c value path to the configuration file (default: \"/etc/containerd/config.toml\") --log-level value, -l value set the logging level [trace, debug, info, warn, error, fatal, panic] --address value, -a value address for containerd's GRPC server --root value containerd root directory --state value containerd state directory --help, -h show help --version, -v print the version ただし、前述したように containerd は daemon として動作する必要があるので、これだけではまだ利用できません。\nGetting started を見ると、どうやら containerd のソースコードに同梱されている containerd.service に言及しています。これを利用して、systemd で containerd を起動することにしてみましょう。\nvagrant@vagrant:~$ sudo apt install -y unzip # unzip を install しておく vagrant@vagrant:~$ wget https://github.com/containerd/containerd/archive/v1.4.3.zip # ソースコードを取得 vagrant@vagrant:~$ unzip v1.4.3.zip vagrant@vagrant:~$ ls containerd-1.4.3 v1.4.3.zip vagrant@vagrant:~$ ls containerd-1.4.3/containerd.service # systemd 向けの service file が存在 containerd-1.4.3/containerd.service vagrant@vagrant:~$ sudo cp containerd-1.4.3/containerd.service /etc/systemd/system/ vagrant@vagrant:~$ sudo systemctl enable containerd Created symlink /etc/systemd/system/multi-user.target.wants/containerd.service → /etc/systemd/system/containerd.service. vagrant@vagrant:~$ sudo systemctl start containerd これで、無事 containerd が起動しました。\nvagrant@vagrant:~$ ps aux | grep containerd root 13444 1.6 4.5 1344964 45620 ? Ssl 16:39 0:00 /usr/local/bin/containerd vagrant 13455 0.0 0.0 9032 664 pts/0 S+ 16:39 0:00 grep --color=auto containerd Getting started の document には /etc/containerd/config.toml の存在も言及されているので、これも用意しておきます。これで準備 OK です。\nvagrant@vagrant:~$ sudo mkdir /etc/containerd vagrant@vagrant:~$ sudo vim /etc/containerd/config.toml # ここで containerd の設定ファイルである config.toml を作成 vagrant@vagrant:~$ sudo systemctl restart containerd # ここで、設定ファイルを読み込む形で containerd を再起動 # これが /etc/containerd/config.toml の内容 subreaper = true oom_score = -999 [debug] level = \"debug\" [metrics] address = \"127.0.0.1:1338\" [plugins.linux] runtime = \"runc\" shim_debug = true さて、containerd が daemon として動くようになりました。次は、containerd と通信するコードを書いてみましょう。Getting started を参考に、以下のような Go コードを書いてみます。\npackage main import ( \"context\" \"fmt\" \"log\" \"syscall\" \"time\" \"github.com/containerd/containerd\" \"github.com/containerd/containerd/cio\" \"github.com/containerd/containerd/namespaces\" \"github.com/containerd/containerd/oci\" ) func main() { if err := redisExample(); err != nil { log.Fatal(err) } } func redisExample() error { // create a new client connected to the default socket path for containerd client, err := containerd.New(\"/run/containerd/containerd.sock\") if err != nil { return err } defer client.Close() // create a new context with an \"example\" namespace ctx := namespaces.WithNamespace(context.Background(), \"example\") // pull the redis image from DockerHub image, err := client.Pull(ctx, \"docker.io/library/redis:alpine\", containerd.WithPullUnpack) if err != nil { return err } // create a container container, err := client.NewContainer( ctx, \"redis-server\", containerd.WithImage(image), containerd.WithNewSnapshot(\"redis-server-snapshot\", image), containerd.WithNewSpec(oci.WithImageConfig(image)), ) if err != nil { return err } defer container.Delete(ctx, containerd.WithSnapshotCleanup) // create a task from the container task, err := container.NewTask(ctx, cio.NewCreator(cio.WithStdio)) if err != nil { return err } defer task.Delete(ctx) // make sure we wait before calling start exitStatusC, err := task.Wait(ctx) if err != nil { fmt.Println(err) } // call start on the task to execute the redis server if err := task.Start(ctx); err != nil { return err } // sleep for a lil bit to see the logs time.Sleep(3 * time.Second) // kill the process and get the exit status if err := task.Kill(ctx, syscall.SIGTERM); err != nil { return err } // wait for the process to fully exit and print out the exit status status := \u003c-exitStatusC // Block here. code, _, err := status.Result() if err != nil { return err } fmt.Printf(\"redis-server exited with status: %d\\n\", code) // For Debug fmt.Printf(\"Client: %v\\n\", client) fmt.Printf(\"Image: %v\\n\", image) fmt.Printf(\"Container: %v\\n\", container) fmt.Printf(\"Task: %v\\n\", task) return nil } 「Go 環境の構築」は良い感じにやってください。その状態で上記の Go コードを実行すると、以下のような出力が行われます。\nvagrant@vagrant:~/containerd-playground$ go build main.go \u0026\u0026 sudo ./main 1:C 10 Dec 2020 17:11:43.852 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo 1:C 10 Dec 2020 17:11:43.852 # Redis version=6.0.9, bits=64, commit=00000000, modified=0, pid=1, just started 1:C 10 Dec 2020 17:11:43.852 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf 1:M 10 Dec 2020 17:11:43.856 # You requested maxclients of 10000 requiring at least 10032 max file descriptors. 1:M 10 Dec 2020 17:11:43.856 # Server can't set maximum open files to 10032 because of OS error: Operation not permitted. 1:M 10 Dec 2020 17:11:43.856 # Current maximum open files is 1024. maxclients has been reduced to 992 to compensate for low ulimit. If you need higher maxclients increase 'ulimit -n'. 1:M 10 Dec 2020 17:11:43.858 * Running mode=standalone, port=6379. 1:M 10 Dec 2020 17:11:43.858 # Server initialized 1:M 10 Dec 2020 17:11:43.858 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect. 1:M 10 Dec 2020 17:11:43.858 * Ready to accept connections 1:signal-handler (1607620306) Received SIGTERM scheduling shutdown... 1:M 10 Dec 2020 17:11:46.877 # User requested shutdown... 1:M 10 Dec 2020 17:11:46.877 * Saving the final RDB snapshot before exiting. 1:M 10 Dec 2020 17:11:46.879 * DB saved on disk 1:M 10 Dec 2020 17:11:46.879 # Redis is now ready to exit, bye bye... redis-server exited with status: 0 Client: \u0026{{ map[] } {0 0} 0xc00010ee00 io.containerd.runc.v2 {0xc0002131a0} 0xe6c020} Image: \u0026{0xc0002f4000 {docker.io/library/redis:alpine map[] {application/vnd.docker.distribution.manifest.list.v2+json sha256:b0e84b6b92149194d99953e44f7d1fa1f470a769529bb05b4164eae60d8aea6c 1645 [] map[] } {312279631 63742833489 } {749989962 63743217103 }} {0xc0002131a0}} Container: \u0026{0xc0002f4000 redis-server {redis-server map[] docker.io/library/redis:alpine {io.containerd.runc.v2 } 0xc0003ce1e0 redis-server-snapshot overlayfs {775955650 63743217103 } {775955650 63743217103 } map[]}} Task: \u0026{0xc0002f4000 0xc0001020c0 0xc0003a86c0 redis-server 65235} 上記の Go コードおよび出力について少し説明します。\n上記の Go コードは「containerd と /run/containerd/containerd.sock を通じて通信する client の動作」が記述されています。コード内では client の作成、Container Image の pull、Container Image からの Snapshot (= Container 実行時に root filesystem として利用するもの) および Spec (= Container 実行時のメタデータ、Filesystem Bundle における config.json に相当) の作成、Task (= container の中で実際に実行したいコマンド) の作成、開始、終了およびその待ち合わせを行っています。 また、最後にデバッグ用途に様々な struct を print してみています（これは Getting started に掲載されていたコードに自分が後から追加したものです）。\nPull している Container Image は docker.io/library/redis:alpine で、ログの出力としても redis server の起動および終了が行われていることが分かります。\nこれで、containerd を実際に利用してみる事が出来ました！\nなお、containerd は OSS でコードが公開されているので、気になった挙動はコードを読んで理解する事が出来ます。例えば、 containerd.WithNewSnapshot や containerd.WithNewSpec というのは以下のコードに該当します。\nhttps://github.com/containerd/containerd/blob/v1.4.3/container_opts.go#L144-L169 https://github.com/containerd/containerd/blob/v1.4.3/container_opts.go#L243-L253\n前者のコードを読み進めると「Snapshotter によって Snapshot 作成を行って、Container には SnapshotKey を設定して id を通して参照できるようにしている」事が分かりますし、後者のコードを読み進めると「OCI Runtime Specification の Go binding で定義された Spec struct が generate されて利用される」事が分かります。「runc などの Low-Level Container Runtime が必要とする情報を用意する」という部分をしっかりやってくれてるようです（注: これは自分がコードを読んだ理解なので、誤解してる可能もあります。何か気がついた際はコメントいただけるとありがたいです）。\nその他、Container Image を Pull している部分や Task の管理部分なども興味深い部分です。気になった箇所はぜひ読み進めて理解を深めてみてください。\nまとめ runc や containerd などの Container Runtime を実際に触ってみる事で、理解を深めました。runc については、OCI Runtime Specification で定義された挙動が CLI tool として提供されている事が分かりました。containerd については、Container Image の Pull や Container Image から Filesystem Bundle 相当の情報（= Container 実行に必要な Snapshot および Spec）への変換、Container や Task の作成・削除・開始などの管理を行っている事が分かりました。\nrunc やcontainerd は扱っている領域が異なる一方で、どちらも「Container Runtime」という名前で呼ばれるために混乱してしまいがちです。実際に手を動かしてみる事で、「それぞれの責任範囲」や「レイヤー構造」について理解が深まったように思います。\nなお、このブログ自体は自分の理解のために試したことをまとめたものですが、誰か他の人にとっても理解を助けるものになっていればとても幸いです。\nVagrant での実験環境 以下のような Vagrantfile を使ってます。ubuntu-20.04 を使ってます。\n# -*- mode: ruby -*- # vi: set ft=ruby : VAGRANTFILE_API_VERSION = \"2\" Vagrant.configure(VAGRANTFILE_API_VERSION) do |config| config.vm.box = \"bento/ubuntu-20.04\" config.vm.synced_folder \"./\", \"/home/vagrant/oci-playground\" end ","wordCount":"2275","inLanguage":"en","datePublished":"2020-12-11T00:00:00+09:00","dateModified":"2020-12-11T00:00:00+09:00","author":{"@type":"Person","name":"Nao Minami"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.south37.net/posts/20201211-container-3/"},"publisher":{"@type":"Organization","name":"South37's Blog","logo":{"@type":"ImageObject","url":"https://www.south37.net/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://www.south37.net/ accesskey=h title="South37's Blog (Alt + H)">South37's Blog</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://www.south37.net/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://www.south37.net/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.south37.net/>Home</a>&nbsp;»&nbsp;<a href=https://www.south37.net/posts/>Posts</a></div><h1 class=post-title>手を動かして学ぶコンテナ標準 - Container Runtime 編</h1><div class=post-meta><span title='2020-12-11 00:00:00 +0900 +0900'>December 11, 2020</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Nao Minami</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#runchttpsgithubcomopencontainersrunc-%e3%82%92%e5%8b%95%e3%81%8b%e3%81%97%e3%81%a6%e3%81%bf%e3%82%8b aria-label="runc を動かしてみる"><a href=https://github.com/opencontainers/runc>runc</a> を動かしてみる</a></li><li><a href=#containerdhttpsgithubcomcontainerdcontainerd-%e3%82%92%e5%8b%95%e3%81%8b%e3%81%97%e3%81%a6%e3%81%bf%e3%82%8b aria-label="containerd を動かしてみる"><a href=https://github.com/containerd/containerd/>containerd</a> を動かしてみる</a></li><li><a href=#%e3%81%be%e3%81%a8%e3%82%81 aria-label=まとめ>まとめ</a></li><li><a href=#vagrant-%e3%81%a7%e3%81%ae%e5%ae%9f%e9%a8%93%e7%92%b0%e5%a2%83 aria-label="Vagrant での実験環境">Vagrant での実験環境</a></li></ul></div></details></div><div class=post-content><p><a href=/posts/20201207-container-1>コンテナ標準化の現状と Kubernetes の立ち位置について</a> というブログではコンテナ標準の現状についてまとめてみました。</p><p>また、<a href=/posts/20201210-container-2>手を動かして学ぶコンテナ標準 - Container Image と Container Registry 編</a> というブログでは Container Image と Container Registry について手を動かして学んでみました。</p><p>このブログでは、<a href=https://github.com/opencontainers/runc>runc</a>, <a href=https://github.com/containerd/containerd>containerd</a> などの Container Runtime について、実際に手を動かして学んでみたいと思います。</p><p>なお、<a href=https://south37.hatenablog.com/entry/2020/12/10/%E6%89%8B%E3%82%92%E5%8B%95%E3%81%8B%E3%81%97%E3%81%A6%E5%AD%A6%E3%81%B6%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E6%A8%99%E6%BA%96_-_Container_Image_%E3%81%A8_Container_Registry_%E7%B7%A8>前回のブログ</a> 同様、基本的にこのブログ内のコマンドは Linux で実行するものとします（自分は MacOS で Vagrant で Ubuntu VM を立てて実験してます）。</p><h2 id=runchttpsgithubcomopencontainersrunc-を動かしてみる><a href=https://github.com/opencontainers/runc>runc</a> を動かしてみる<a hidden class=anchor aria-hidden=true href=#runchttpsgithubcomopencontainersrunc-を動かしてみる>#</a></h2><p><a href=https://github.com/opencontainers/runc>runc</a> は Low-Level Container Runtime と呼ばれるもので、<a href=https://github.com/opencontainers/runtime-spec/blob/v1.0.2/spec.md>OCI Runtime Specification</a> に準拠した CLI tool となっています。実際に runc を動かしてみることで、Container Runtime に対して理解を深めてみましょう。</p><p>まず runc の install ですが、自分が試している ubuntu-20.04 では <code>apt</code> で install することができます。</p><pre tabindex=0><code>vagrant@vagrant:~$ sudo apt update -y
vagrant@vagrant:~$ sudo apt install -y runc
vagrant@vagrant:~$ which runc
/usr/sbin/runc
</code></pre><p>help を見てみると以下のような内容になっていて、container を操作するために必要な各種 subcommand が存在することがわかります。実は、これらの subcommand によって <a href=https://github.com/opencontainers/runtime-spec/blob/v1.0.2/runtime.md>OCI Runtime Specification</a> の <a href=https://github.com/opencontainers/runtime-spec/blob/v1.0.2/runtime.md>Runtime and Lifecycle</a> で定義された「Operations」 の機能が提供されています。ただし、見比べてみると分かりますが runc 自体はよりリッチな機能を提供しているようです。</p><pre tabindex=0><code>vagrant@vagrant:~$ runc --help
NAME:
   runc - Open Container Initiative runtime

runc is a command line client for running applications packaged according to
the Open Container Initiative (OCI) format and is a compliant implementation of the
Open Container Initiative specification.

runc integrates well with existing process supervisors to provide a production
container runtime environment for applications. It can be used with your
existing process monitoring tools and the container will be spawned as a
direct child of the process supervisor.

Containers are configured using bundles. A bundle for a container is a directory
that includes a specification file named &#34;config.json&#34; and a root filesystem.
The root filesystem contains the contents of the container.

To start a new instance of a container:

    # runc run [ -b bundle ] &lt;container-id&gt;

Where &#34;&lt;container-id&gt;&#34; is your name for the instance of the container that you
are starting. The name you provide for the container instance must be unique on
your host. Providing the bundle directory using &#34;-b&#34; is optional. The default
value for &#34;bundle&#34; is the current directory.

USAGE:
   runc [global options] command [command options] [arguments...]

VERSION:
   spec: 1.0.1-dev

COMMANDS:
     checkpoint  checkpoint a running container
     create      create a container
     delete      delete any resources held by the container often used with detached container
     events      display container events such as OOM notifications, cpu, memory, and IO usage statistics
     exec        execute new process inside the container
     init        initialize the namespaces and launch the process (do not call it outside of runc)
     kill        kill sends the specified signal (default: SIGTERM) to the container&#39;s init process
     list        lists containers started by runc with the given root
     pause       pause suspends all processes inside the container
     ps          ps displays the processes running inside a container
     restore     restore a container from a previous checkpoint
     resume      resumes all processes that have been previously paused
     run         create and run a container
     spec        create a new specification file
     start       executes the user defined process in a created container
     state       output the state of a container
     update      update container resource constraints
     help, h     Shows a list of commands or help for one command

GLOBAL OPTIONS:
   --debug             enable debug output for logging
   --log value         set the log file path where internal debug information is written
   --log-format value  set the format used by logs (&#39;text&#39; (default), or &#39;json&#39;) (default: &#34;text&#34;)
   --root value        root directory for storage of container state (this should be located in tmpfs) (default: &#34;/run/user/1000/runc&#34;)
   --criu value        path to the criu binary used for checkpoint and restore (default: &#34;criu&#34;)
   --systemd-cgroup    enable systemd cgroup support, expects cgroupsPath to be of form &#34;slice:prefix:name&#34; for e.g. &#34;system.slice:runc:434234&#34;
   --rootless value    ignore cgroup permission errors (&#39;true&#39;, &#39;false&#39;, or &#39;auto&#39;) (default: &#34;auto&#34;)
   --help, -h          show help
   --version, -v       print the version
</code></pre><p>実際に runc を利用して container を起動してみましょう。runc の README の <a href=https://github.com/opencontainers/runc#using-runc>Using runc</a> というセクションがぴったりの題材なので、これを参考にしてみます。</p><p><a href=https://github.com/opencontainers/runtime-spec/blob/v1.0.2/spec.md>OCI Runtime Speicification</a> の内容を見てもらうと分かるのですが、runc のような Low-Level Container Runtime は <a href=https://github.com/opencontainers/runtime-spec/blob/v1.0.2/bundle.md>Filesystem Bundle</a> と呼ばれる「Container を起動するのに利用される configuration file と、container にとっての root filesystem となる directory の組み合わせ」を必要とします。まずはこの Filesystem Bundle を用意します。</p><p>Filesystem Bundle は <a href=https://github.com/opencontainers/runtime-spec/blob/v1.0.2/config.md>config.json</a> と呼ばれる configuration file と、その config.json の中の <code>root.path</code> で path を指定される 「container の root filesystem となる directory」から構成されます。それぞれ順番に作成していきます。</p><p>まずは Filesystem Bundle を格納する directory として <code>mycontainer</code> という directory を作っておきます。</p><pre tabindex=0><code>vagrant@vagrant:~$ mkdir mycontainer
vagrant@vagrant:~$ cd mycontainer/
</code></pre><p>次に、<code>config.json</code> についてですが、 <code>$ runc spec</code> を実行すると自動でデフォルト設定の <code>config.json</code> が作成されます。今回はこれを使うことにしましょう。</p><pre tabindex=0><code>vagrant@vagrant:~/mycontainer$ runc spec
vagrant@vagrant:~/mycontainer$ ls
config.json
</code></pre><p>デフォルト設定の config.json は以下のような内容になっています。実行時のコマンドや環境変数、root.path などに加えて、namespace や volume mount, capability の設定なども記載されています。</p><pre tabindex=0><code>
vagrant@vagrant:~/mycontainer$ cat config.json
{
        &#34;ociVersion&#34;: &#34;1.0.1-dev&#34;,
        &#34;process&#34;: {
                &#34;terminal&#34;: true,
                &#34;user&#34;: {
                        &#34;uid&#34;: 0,
                        &#34;gid&#34;: 0
                },
                &#34;args&#34;: [
                        &#34;sh&#34;
                ],
                &#34;env&#34;: [
                        &#34;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&#34;,
                        &#34;TERM=xterm&#34;
                ],
                &#34;cwd&#34;: &#34;/&#34;,
                &#34;capabilities&#34;: {
                        &#34;bounding&#34;: [
                                &#34;CAP_AUDIT_WRITE&#34;,
                                &#34;CAP_KILL&#34;,
                                &#34;CAP_NET_BIND_SERVICE&#34;
                        ],
                        &#34;effective&#34;: [
                                &#34;CAP_AUDIT_WRITE&#34;,
                                &#34;CAP_KILL&#34;,
                                &#34;CAP_NET_BIND_SERVICE&#34;
                        ],
                        &#34;inheritable&#34;: [
                                &#34;CAP_AUDIT_WRITE&#34;,
                                &#34;CAP_KILL&#34;,
                                &#34;CAP_NET_BIND_SERVICE&#34;
                        ],
                        &#34;permitted&#34;: [
                                &#34;CAP_AUDIT_WRITE&#34;,
                                &#34;CAP_KILL&#34;,
                                &#34;CAP_NET_BIND_SERVICE&#34;
                        ],
                        &#34;ambient&#34;: [
                                &#34;CAP_AUDIT_WRITE&#34;,
                                &#34;CAP_KILL&#34;,
                                &#34;CAP_NET_BIND_SERVICE&#34;
                        ]
                },
                &#34;rlimits&#34;: [
                        {
                                &#34;type&#34;: &#34;RLIMIT_NOFILE&#34;,
                                &#34;hard&#34;: 1024,
                                &#34;soft&#34;: 1024
                        }
                ],
                &#34;noNewPrivileges&#34;: true
        },
        &#34;root&#34;: {
                &#34;path&#34;: &#34;rootfs&#34;,
                &#34;readonly&#34;: true
        },
        &#34;hostname&#34;: &#34;runc&#34;,
        &#34;mounts&#34;: [
                {
                        &#34;destination&#34;: &#34;/proc&#34;,
                        &#34;type&#34;: &#34;proc&#34;,
                        &#34;source&#34;: &#34;proc&#34;
                },
                {
                        &#34;destination&#34;: &#34;/dev&#34;,
                        &#34;type&#34;: &#34;tmpfs&#34;,
                        &#34;source&#34;: &#34;tmpfs&#34;,
                        &#34;options&#34;: [
                                &#34;nosuid&#34;,
                                &#34;strictatime&#34;,
                                &#34;mode=755&#34;,
                                &#34;size=65536k&#34;
                        ]
                },
                {
                        &#34;destination&#34;: &#34;/dev/pts&#34;,
                        &#34;type&#34;: &#34;devpts&#34;,
                        &#34;source&#34;: &#34;devpts&#34;,
                        &#34;options&#34;: [
                                &#34;nosuid&#34;,
                                &#34;noexec&#34;,
                                &#34;newinstance&#34;,
                                &#34;ptmxmode=0666&#34;,
                                &#34;mode=0620&#34;,
                                &#34;gid=5&#34;
                        ]
                },
                {
                        &#34;destination&#34;: &#34;/dev/shm&#34;,
                        &#34;type&#34;: &#34;tmpfs&#34;,
                        &#34;source&#34;: &#34;shm&#34;,
                        &#34;options&#34;: [
                                &#34;nosuid&#34;,
                                &#34;noexec&#34;,
                                &#34;nodev&#34;,
                                &#34;mode=1777&#34;,
                                &#34;size=65536k&#34;
                        ]
                },
                {
                        &#34;destination&#34;: &#34;/dev/mqueue&#34;,
                        &#34;type&#34;: &#34;mqueue&#34;,
                        &#34;source&#34;: &#34;mqueue&#34;,
                        &#34;options&#34;: [
                                &#34;nosuid&#34;,
                                &#34;noexec&#34;,
                                &#34;nodev&#34;
                        ]
                },
                {
                        &#34;destination&#34;: &#34;/sys&#34;,
                        &#34;type&#34;: &#34;sysfs&#34;,
                        &#34;source&#34;: &#34;sysfs&#34;,
                        &#34;options&#34;: [
                                &#34;nosuid&#34;,
                                &#34;noexec&#34;,
                                &#34;nodev&#34;,
                                &#34;ro&#34;
                        ]
                },
                {
                        &#34;destination&#34;: &#34;/sys/fs/cgroup&#34;,
                        &#34;type&#34;: &#34;cgroup&#34;,
                        &#34;source&#34;: &#34;cgroup&#34;,
                        &#34;options&#34;: [
                                &#34;nosuid&#34;,
                                &#34;noexec&#34;,
                                &#34;nodev&#34;,
                                &#34;relatime&#34;,
                                &#34;ro&#34;
                        ]
                }
        ],
        &#34;linux&#34;: {
                &#34;resources&#34;: {
                        &#34;devices&#34;: [
                                {
                                        &#34;allow&#34;: false,
                                        &#34;access&#34;: &#34;rwm&#34;
                                }
                        ]
                },
                &#34;namespaces&#34;: [
                        {
                                &#34;type&#34;: &#34;pid&#34;
                        },
                        {
                                &#34;type&#34;: &#34;network&#34;
                        },
                        {
                                &#34;type&#34;: &#34;ipc&#34;
                        },
                        {
                                &#34;type&#34;: &#34;uts&#34;
                        },
                        {
                                &#34;type&#34;: &#34;mount&#34;
                        }
                ],
                &#34;maskedPaths&#34;: [
                        &#34;/proc/acpi&#34;,
                        &#34;/proc/asound&#34;,
                        &#34;/proc/kcore&#34;,
                        &#34;/proc/keys&#34;,
                        &#34;/proc/latency_stats&#34;,
                        &#34;/proc/timer_list&#34;,
                        &#34;/proc/timer_stats&#34;,
                        &#34;/proc/sched_debug&#34;,
                        &#34;/sys/firmware&#34;,
                        &#34;/proc/scsi&#34;
                ],
                &#34;readonlyPaths&#34;: [
                        &#34;/proc/bus&#34;,
                        &#34;/proc/fs&#34;,
                        &#34;/proc/irq&#34;,
                        &#34;/proc/sys&#34;,
                        &#34;/proc/sysrq-trigger&#34;
                ]
        }
</code></pre><p>次に、container の root filesystem となる directory を用意します。今回は楽をするために、「<code>$ docker export</code> の機能を利用する」ことにします（自分は vagrant で synced_folder した directory で docker export しました）。原理的には、どんな手段で用意しても良いはずです。</p><pre tabindex=0><code>$ mkdir rootfs
$ docker export $(docker create busybox) | tar -C rootfs -xvf -
</code></pre><p>上記コマンドまで実行が終わると、<code>mycontainer</code> directory の中は以下のような状態になっているはずです。</p><pre tabindex=0><code>vagrant@vagrant:~/mycontainer$ ls
config.json  rootfs
</code></pre><p>この状態で <code>$ sudo runc run containerid</code> を実行すると、container が起動します。</p><pre tabindex=0><code>vagrant@vagrant:~/oci-playground/runc-playground/mycontainer2$ sudo runc run containerid
/ #
</code></pre><p>上記で作成した <code>config.json</code> はデフォルトで「<code>sh</code> コマンドを実行する」という設定になっているので、<code>sh</code> が起動しています。</p><p>そのため、一度 exit してから <code>config.json</code> を例えば「<code>ls</code> を実行するもの」に書き換えると、<code>ls</code> が container 内で実行されます。</p><pre tabindex=0><code>vagrant@vagrant:~/oci-playground/runc-playground/mycontainer2$ vim config.json  # ここで以下のように変更
                &#34;args&#34;: [
-                       &#34;sh&#34;
+                       &#34;ls&#34;
                ],

vagrant@vagrant:~/oci-playground/runc-playground/mycontainer2$ sudo runc run containerid
bin   dev   etc   home  proc  root  sys   tmp   usr   var
</code></pre><p>ということで、<code>runc</code> を利用して無事に container を起動することができました！</p><p>config.json + container の root filesystem になる directory という「Filesystem Bundle」を用意さえすれば、「container の起動が簡単に出来る」ということが分かったかと思います。なお、これは <a href=https://github.com/opencontainers/runtime-spec/blob/v1.0.2/spec.md>OCI Runtime Specification</a> で定められている挙動であるため、この仕様を満たしてさえいれば「runc 以外の Low-Level Container Runtime」においても同様のことができるはずです。</p><p>上記の例では <code>runc run</code> を利用しましたが、その他のオペレーション（create, start, delete など）を利用することでより細かな制御も可能です。詳細が気になる方は、ぜひご自分でも試してみてください。</p><h2 id=containerdhttpsgithubcomcontainerdcontainerd-を動かしてみる><a href=https://github.com/containerd/containerd/>containerd</a> を動かしてみる<a hidden class=anchor aria-hidden=true href=#containerdhttpsgithubcomcontainerdcontainerd-を動かしてみる>#</a></h2><p>Low-Level Container Runtime の runc の次は、High-Level Container Runtime である <a href=https://github.com/containerd/containerd>containerd</a> を動かしてみましょう。runc は「container を起動する」という部分は実行してくれましたが、それ以外の「Container Image の Pull、Container Image から Filesystem Bundle への変換」などはやってくれませんでした。実は、この部分の機能を提供してくれてるのが containerd です。</p><p>containerd は、daemon として常駐して、client からの request を受け付けて動作するという振る舞いになっています。containerd の動作のイメージを掴むために、<a href=https://containerd.io/docs/getting-started/>Getting started</a> というページに従って containerd を利用してみましょう。</p><p>まずは、<a href=https://containerd.io/downloads/>containerd downloads の Installing binaries</a> に従って containerd の binary を download します。そして、その binary を <code>/usr/local/bin</code> など PATH の通った場所に配置します。</p><pre tabindex=0><code>vagrant@vagrant:~$ wget https://github.com/containerd/containerd/releases/download/v1.4.3/containerd-1.4.3-linux-amd64.tar.gz
vagrant@vagrant:~$ tar xvf containerd-1.4.3-linux-amd64.tar.gz
vagrant@vagrant:~$ sudo mv bin/* /usr/local/bin/
</code></pre><p>これで、<code>containerd</code> がコマンドとして利用できるようになります。</p><pre tabindex=0><code>vagrant@vagrant:~$ which containerd
/usr/local/bin/containerd

vagrant@vagrant:~$ containerd --help
NAME:
   containerd -
                    __        _                     __
  _________  ____  / /_____ _(_)___  ___  _________/ /
 / ___/ __ \/ __ \/ __/ __ `/ / __ \/ _ \/ ___/ __  /
/ /__/ /_/ / / / / /_/ /_/ / / / / /  __/ /  / /_/ /
\___/\____/_/ /_/\__/\__,_/_/_/ /_/\___/_/   \__,_/

high performance container runtime


USAGE:
   containerd [global options] command [command options] [arguments...]

VERSION:
   v1.4.3

DESCRIPTION:

containerd is a high performance container runtime whose daemon can be started
by using this command. If none of the *config*, *publish*, or *help* commands
are specified, the default action of the **containerd** command is to start the
containerd daemon in the foreground.


A default configuration is used if no TOML configuration is specified or located
at the default file location. The *containerd config* command can be used to
generate the default configuration for containerd. The output of that command
can be used and modified as necessary as a custom configuration.

COMMANDS:
   config    information on the containerd config
   publish   binary to publish events to containerd
   oci-hook  provides a base for OCI runtime hooks to allow arguments to be injected.
   help, h   Shows a list of commands or help for one command

GLOBAL OPTIONS:
   --config value, -c value     path to the configuration file (default: &#34;/etc/containerd/config.toml&#34;)
   --log-level value, -l value  set the logging level [trace, debug, info, warn, error, fatal, panic]
   --address value, -a value    address for containerd&#39;s GRPC server
   --root value                 containerd root directory
   --state value                containerd state directory
   --help, -h                   show help
   --version, -v                print the version
</code></pre><p>ただし、前述したように containerd は daemon として動作する必要があるので、これだけではまだ利用できません。</p><p><a href=https://containerd.io/docs/getting-started>Getting started</a> を見ると、どうやら containerd のソースコードに同梱されている containerd.service に言及しています。これを利用して、systemd で containerd を起動することにしてみましょう。</p><pre tabindex=0><code>vagrant@vagrant:~$ sudo apt install -y unzip  # unzip を install しておく

vagrant@vagrant:~$ wget https://github.com/containerd/containerd/archive/v1.4.3.zip  # ソースコードを取得
vagrant@vagrant:~$ unzip v1.4.3.zip
vagrant@vagrant:~$ ls
containerd-1.4.3  v1.4.3.zip

vagrant@vagrant:~$ ls containerd-1.4.3/containerd.service  # systemd 向けの service file が存在
containerd-1.4.3/containerd.service

vagrant@vagrant:~$ sudo cp containerd-1.4.3/containerd.service /etc/systemd/system/
vagrant@vagrant:~$ sudo systemctl enable containerd
Created symlink /etc/systemd/system/multi-user.target.wants/containerd.service → /etc/systemd/system/containerd.service.
vagrant@vagrant:~$ sudo systemctl start containerd
</code></pre><p>これで、無事 containerd が起動しました。</p><pre tabindex=0><code>vagrant@vagrant:~$ ps aux | grep containerd
root       13444  1.6  4.5 1344964 45620 ?       Ssl  16:39   0:00 /usr/local/bin/containerd
vagrant    13455  0.0  0.0   9032   664 pts/0    S+   16:39   0:00 grep --color=auto containerd
</code></pre><p><a href=https://containerd.io/docs/getting-started/>Getting started</a> の document には <code>/etc/containerd/config.toml</code> の存在も言及されているので、これも用意しておきます。これで準備 OK です。</p><pre tabindex=0><code>vagrant@vagrant:~$ sudo mkdir /etc/containerd
vagrant@vagrant:~$ sudo vim /etc/containerd/config.toml  # ここで containerd の設定ファイルである config.toml を作成
vagrant@vagrant:~$ sudo systemctl restart containerd  # ここで、設定ファイルを読み込む形で containerd を再起動
</code></pre><div class=highlight><pre tabindex=0 class=chroma><code class=language-toml data-lang=toml><span class=line><span class=cl><span class=c># これが /etc/containerd/config.toml の内容</span>
</span></span><span class=line><span class=cl><span class=nx>subreaper</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=nx>oom_score</span> <span class=p>=</span> <span class=mi>-999</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=nx>debug</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=nx>level</span> <span class=p>=</span> <span class=s2>&#34;debug&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=nx>metrics</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=nx>address</span> <span class=p>=</span> <span class=s2>&#34;127.0.0.1:1338&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=nx>plugins</span><span class=p>.</span><span class=nx>linux</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=nx>runtime</span> <span class=p>=</span> <span class=s2>&#34;runc&#34;</span>
</span></span><span class=line><span class=cl>        <span class=nx>shim_debug</span> <span class=p>=</span> <span class=kc>true</span>
</span></span></code></pre></div><p>さて、containerd が daemon として動くようになりました。次は、containerd と通信するコードを書いてみましょう。<a href=https://containerd.io/docs/getting-started/>Getting started</a> を参考に、以下のような Go コードを書いてみます。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;context&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;log&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;syscall&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=s>&#34;github.com/containerd/containerd&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;github.com/containerd/containerd/cio&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;github.com/containerd/containerd/namespaces&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;github.com/containerd/containerd/oci&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>redisExample</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>redisExample</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// create a new client connected to the default socket path for containerd
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>client</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>containerd</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;/run/containerd/containerd.sock&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>client</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// create a new context with an &#34;example&#34; namespace
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>ctx</span> <span class=o>:=</span> <span class=nx>namespaces</span><span class=p>.</span><span class=nf>WithNamespace</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>(),</span> <span class=s>&#34;example&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// pull the redis image from DockerHub
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>image</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>client</span><span class=p>.</span><span class=nf>Pull</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;docker.io/library/redis:alpine&#34;</span><span class=p>,</span> <span class=nx>containerd</span><span class=p>.</span><span class=nx>WithPullUnpack</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// create a container
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>container</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>client</span><span class=p>.</span><span class=nf>NewContainer</span><span class=p>(</span>
</span></span><span class=line><span class=cl>		<span class=nx>ctx</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=s>&#34;redis-server&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>containerd</span><span class=p>.</span><span class=nf>WithImage</span><span class=p>(</span><span class=nx>image</span><span class=p>),</span>
</span></span><span class=line><span class=cl>		<span class=nx>containerd</span><span class=p>.</span><span class=nf>WithNewSnapshot</span><span class=p>(</span><span class=s>&#34;redis-server-snapshot&#34;</span><span class=p>,</span> <span class=nx>image</span><span class=p>),</span>
</span></span><span class=line><span class=cl>		<span class=nx>containerd</span><span class=p>.</span><span class=nf>WithNewSpec</span><span class=p>(</span><span class=nx>oci</span><span class=p>.</span><span class=nf>WithImageConfig</span><span class=p>(</span><span class=nx>image</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>	<span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>container</span><span class=p>.</span><span class=nf>Delete</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>containerd</span><span class=p>.</span><span class=nx>WithSnapshotCleanup</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// create a task from the container
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>task</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>container</span><span class=p>.</span><span class=nf>NewTask</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>cio</span><span class=p>.</span><span class=nf>NewCreator</span><span class=p>(</span><span class=nx>cio</span><span class=p>.</span><span class=nx>WithStdio</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>task</span><span class=p>.</span><span class=nf>Delete</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// make sure we wait before calling start
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>exitStatusC</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>task</span><span class=p>.</span><span class=nf>Wait</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// call start on the task to execute the redis server
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>task</span><span class=p>.</span><span class=nf>Start</span><span class=p>(</span><span class=nx>ctx</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// sleep for a lil bit to see the logs
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>3</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// kill the process and get the exit status
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>task</span><span class=p>.</span><span class=nf>Kill</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>SIGTERM</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// wait for the process to fully exit and print out the exit status
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>status</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>exitStatusC</span> <span class=c1>// Block here.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>code</span><span class=p>,</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>status</span><span class=p>.</span><span class=nf>Result</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;redis-server exited with status: %d\n&#34;</span><span class=p>,</span> <span class=nx>code</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// For Debug
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Client: %v\n&#34;</span><span class=p>,</span> <span class=nx>client</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Image: %v\n&#34;</span><span class=p>,</span> <span class=nx>image</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Container: %v\n&#34;</span><span class=p>,</span> <span class=nx>container</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Task: %v\n&#34;</span><span class=p>,</span> <span class=nx>task</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>「Go 環境の構築」は良い感じにやってください。その状態で上記の Go コードを実行すると、以下のような出力が行われます。</p><pre tabindex=0><code>vagrant@vagrant:~/containerd-playground$ go build main.go &amp;&amp; sudo ./main
1:C 10 Dec 2020 17:11:43.852 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
1:C 10 Dec 2020 17:11:43.852 # Redis version=6.0.9, bits=64, commit=00000000, modified=0, pid=1, just started
1:C 10 Dec 2020 17:11:43.852 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf
1:M 10 Dec 2020 17:11:43.856 # You requested maxclients of 10000 requiring at least 10032 max file descriptors.
1:M 10 Dec 2020 17:11:43.856 # Server can&#39;t set maximum open files to 10032 because of OS error: Operation not permitted.
1:M 10 Dec 2020 17:11:43.856 # Current maximum open files is 1024. maxclients has been reduced to 992 to compensate for low ulimit. If you need higher maxclients increase &#39;ulimit -n&#39;.
1:M 10 Dec 2020 17:11:43.858 * Running mode=standalone, port=6379.
1:M 10 Dec 2020 17:11:43.858 # Server initialized
1:M 10 Dec 2020 17:11:43.858 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add &#39;vm.overcommit_memory = 1&#39; to /etc/sysctl.conf and then reboot or run the command &#39;sysctl vm.overcommit_memory=1&#39; for this to take effect.
1:M 10 Dec 2020 17:11:43.858 * Ready to accept connections
1:signal-handler (1607620306) Received SIGTERM scheduling shutdown...
1:M 10 Dec 2020 17:11:46.877 # User requested shutdown...
1:M 10 Dec 2020 17:11:46.877 * Saving the final RDB snapshot before exiting.
1:M 10 Dec 2020 17:11:46.879 * DB saved on disk
1:M 10 Dec 2020 17:11:46.879 # Redis is now ready to exit, bye bye...
redis-server exited with status: 0
Client: &amp;{{ &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; map[] &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt;} {0 0} 0xc00010ee00 io.containerd.runc.v2  {0xc0002131a0} 0xe6c020}
Image: &amp;{0xc0002f4000 {docker.io/library/redis:alpine map[] {application/vnd.docker.distribution.manifest.list.v2+json sha256:b0e84b6b92149194d99953e44f7d1fa1f470a769529bb05b4164eae60d8aea6c 1645 [] map[] &lt;nil&gt;} {312279631 63742833489 &lt;nil&gt;} {749989962 63743217103 &lt;nil&gt;}} {0xc0002131a0}}
Container: &amp;{0xc0002f4000 redis-server {redis-server map[] docker.io/library/redis:alpine {io.containerd.runc.v2 &lt;nil&gt;} 0xc0003ce1e0 redis-server-snapshot overlayfs {775955650 63743217103 &lt;nil&gt;} {775955650 63743217103 &lt;nil&gt;} map[]}}
Task: &amp;{0xc0002f4000 0xc0001020c0 0xc0003a86c0 redis-server 65235}
</code></pre><p>上記の Go コードおよび出力について少し説明します。</p><p>上記の Go コードは「containerd と <code>/run/containerd/containerd.sock</code> を通じて通信する client の動作」が記述されています。コード内では client の作成、Container Image の pull、Container Image からの Snapshot (= Container 実行時に root filesystem として利用するもの) および Spec (= Container 実行時のメタデータ、Filesystem Bundle における config.json に相当) の作成、Task (= container の中で実際に実行したいコマンド) の作成、開始、終了およびその待ち合わせを行っています。
また、最後にデバッグ用途に様々な struct を print してみています（これは <a href=https://containerd.io/docs/getting-started/>Getting started</a> に掲載されていたコードに自分が後から追加したものです）。</p><p>Pull している Container Image は <code>docker.io/library/redis:alpine</code> で、ログの出力としても redis server の起動および終了が行われていることが分かります。</p><p>これで、containerd を実際に利用してみる事が出来ました！</p><p>なお、containerd は OSS でコードが公開されているので、気になった挙動はコードを読んで理解する事が出来ます。例えば、 <code>containerd.WithNewSnapshot</code> や <code>containerd.WithNewSpec</code> というのは以下のコードに該当します。</p><p><a href=https://github.com/containerd/containerd/blob/v1.4.3/container_opts.go#L144-L169>https://github.com/containerd/containerd/blob/v1.4.3/container_opts.go#L144-L169</a>
<a href=https://github.com/containerd/containerd/blob/v1.4.3/container_opts.go#L243-L253>https://github.com/containerd/containerd/blob/v1.4.3/container_opts.go#L243-L253</a></p><p>前者のコードを読み進めると「Snapshotter によって Snapshot 作成を行って、Container には SnapshotKey を設定して id を通して参照できるようにしている」事が分かりますし、後者のコードを読み進めると「<a href=https://github.com/opencontainers/runtime-spec/blob/v1.0.2/specs-go/config.go>OCI Runtime Specification の Go binding</a> で定義された <code>Spec</code> struct が generate されて利用される」事が分かります。「runc などの Low-Level Container Runtime が必要とする情報を用意する」という部分をしっかりやってくれてるようです（注: これは自分がコードを読んだ理解なので、誤解してる可能もあります。何か気がついた際はコメントいただけるとありがたいです）。</p><p>その他、Container Image を Pull している部分や Task の管理部分なども興味深い部分です。気になった箇所はぜひ読み進めて理解を深めてみてください。</p><h2 id=まとめ>まとめ<a hidden class=anchor aria-hidden=true href=#まとめ>#</a></h2><p><a href=https://github.com/opencontainers/runc>runc</a> や <a href=https://github.com/containerd/containerd>containerd</a> などの Container Runtime を実際に触ってみる事で、理解を深めました。runc については、<a href=https://github.com/opencontainers/runtime-spec/blob/v1.0.2/spec.md>OCI Runtime Specification</a> で定義された挙動が CLI tool として提供されている事が分かりました。containerd については、Container Image の Pull や Container Image から <a href=https://github.com/opencontainers/runtime-spec/blob/v1.0.2/bundle.md>Filesystem Bundle</a> 相当の情報（= Container 実行に必要な Snapshot および Spec）への変換、Container や Task の作成・削除・開始などの管理を行っている事が分かりました。</p><p><a href=https://github.com/opencontainers/runc>runc</a> や<a href=https://github.com/containerd/containerd>containerd</a> は扱っている領域が異なる一方で、どちらも「Container Runtime」という名前で呼ばれるために混乱してしまいがちです。実際に手を動かしてみる事で、「それぞれの責任範囲」や「レイヤー構造」について理解が深まったように思います。</p><p>なお、このブログ自体は自分の理解のために試したことをまとめたものですが、誰か他の人にとっても理解を助けるものになっていればとても幸いです。</p><h2 id=vagrant-での実験環境>Vagrant での実験環境<a hidden class=anchor aria-hidden=true href=#vagrant-での実験環境>#</a></h2><p>以下のような Vagrantfile を使ってます。ubuntu-20.04 を使ってます。</p><pre tabindex=0><code># -*- mode: ruby -*-
# vi: set ft=ruby :

VAGRANTFILE_API_VERSION = &#34;2&#34;

Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
  config.vm.box = &#34;bento/ubuntu-20.04&#34;
  config.vm.synced_folder &#34;./&#34;, &#34;/home/vagrant/oci-playground&#34;
end
</code></pre></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://www.south37.net/posts/20201228-bigquery/><span class=title>« Prev</span><br><span>BigQuery の内部実装の変遷について</span></a>
<a class=next href=https://www.south37.net/posts/20201210-container-2/><span class=title>Next »</span><br><span>手を動かして学ぶコンテナ標準 - Container Image と Container Registry 編</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 手を動かして学ぶコンテナ標準 - Container Runtime 編 on twitter" href="https://twitter.com/intent/tweet/?text=%e6%89%8b%e3%82%92%e5%8b%95%e3%81%8b%e3%81%97%e3%81%a6%e5%ad%a6%e3%81%b6%e3%82%b3%e3%83%b3%e3%83%86%e3%83%8a%e6%a8%99%e6%ba%96%20-%20Container%20Runtime%20%e7%b7%a8&amp;url=https%3a%2f%2fwww.south37.net%2fposts%2f20201211-container-3%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 手を動かして学ぶコンテナ標準 - Container Runtime 編 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwww.south37.net%2fposts%2f20201211-container-3%2f&amp;title=%e6%89%8b%e3%82%92%e5%8b%95%e3%81%8b%e3%81%97%e3%81%a6%e5%ad%a6%e3%81%b6%e3%82%b3%e3%83%b3%e3%83%86%e3%83%8a%e6%a8%99%e6%ba%96%20-%20Container%20Runtime%20%e7%b7%a8&amp;summary=%e6%89%8b%e3%82%92%e5%8b%95%e3%81%8b%e3%81%97%e3%81%a6%e5%ad%a6%e3%81%b6%e3%82%b3%e3%83%b3%e3%83%86%e3%83%8a%e6%a8%99%e6%ba%96%20-%20Container%20Runtime%20%e7%b7%a8&amp;source=https%3a%2f%2fwww.south37.net%2fposts%2f20201211-container-3%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 手を動かして学ぶコンテナ標準 - Container Runtime 編 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.south37.net%2fposts%2f20201211-container-3%2f&title=%e6%89%8b%e3%82%92%e5%8b%95%e3%81%8b%e3%81%97%e3%81%a6%e5%ad%a6%e3%81%b6%e3%82%b3%e3%83%b3%e3%83%86%e3%83%8a%e6%a8%99%e6%ba%96%20-%20Container%20Runtime%20%e7%b7%a8"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 手を動かして学ぶコンテナ標準 - Container Runtime 編 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.south37.net%2fposts%2f20201211-container-3%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 手を動かして学ぶコンテナ標準 - Container Runtime 編 on whatsapp" href="https://api.whatsapp.com/send?text=%e6%89%8b%e3%82%92%e5%8b%95%e3%81%8b%e3%81%97%e3%81%a6%e5%ad%a6%e3%81%b6%e3%82%b3%e3%83%b3%e3%83%86%e3%83%8a%e6%a8%99%e6%ba%96%20-%20Container%20Runtime%20%e7%b7%a8%20-%20https%3a%2f%2fwww.south37.net%2fposts%2f20201211-container-3%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 手を動かして学ぶコンテナ標準 - Container Runtime 編 on telegram" href="https://telegram.me/share/url?text=%e6%89%8b%e3%82%92%e5%8b%95%e3%81%8b%e3%81%97%e3%81%a6%e5%ad%a6%e3%81%b6%e3%82%b3%e3%83%b3%e3%83%86%e3%83%8a%e6%a8%99%e6%ba%96%20-%20Container%20Runtime%20%e7%b7%a8&amp;url=https%3a%2f%2fwww.south37.net%2fposts%2f20201211-container-3%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://www.south37.net/>South37's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>