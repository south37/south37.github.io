<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | South37's Blog</title><meta name=keywords content><meta name=description content="Posts - South37's Blog"><meta name=author content="Nao Minami"><link rel=canonical href=https://south37.link/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.b183800e2cfbb62c3bce2b2ba56cdb2dd33af76c75cf4550173d5dfebd7c68a6.css integrity="sha256-sYOADiz7tiw7zisrpWzbLdM692x1z0VQFz1d/r18aKY=" rel="preload stylesheet" as=style><link rel=icon href=https://south37.link/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://south37.link/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://south37.link/favicon-32x32.png><link rel=apple-touch-icon href=https://south37.link/apple-touch-icon.png><link rel=mask-icon href=https://south37.link/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://south37.link/posts/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Posts"><meta property="og:description" content="South37's Blog"><meta property="og:type" content="website"><meta property="og:url" content="https://south37.link/posts/"><meta property="og:image" content="https://south37.link/papermod-cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://south37.link/papermod-cover.png"><meta name=twitter:title content="Posts"><meta name=twitter:description content="South37's Blog"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://south37.link/posts/"}]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://south37.link/ accesskey=h title="South37's Blog (Alt + H)">South37's Blog</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://south37.link/archives title=Archive><span>Archive</span></a></li><li><a href=https://south37.link/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://south37.link/>Home</a></div><h1>Posts
<a href=index.xml title=RSS aria-label=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2>mold の Build 手順メモ</h2></header><div class=entry-content><p>はじめに mold と呼ばれる高速なリンカを利用して Chromium を Build してみる という記事の中で、mold と呼ばれる「高速なリンカ」について紹介しました。
https://github.com/rui314/mold
mold は、自分の知る限りでは現時点では特に Binary の配信などは行っていないようです。利用したい場合には repository を git clone して、自分で Build して利用する必要があります。
mold の Build 手順についてメモ程度に記録を残しておこうと思います。
2021年3月20日追記: ちょうど4日ほど前に mold の README に How to build というセクションが追加されたようです。最新のソースコードで Build する場合は、そちらを参照してみてください。cf. https://github.com/rui314/mold#how-to-build
ステップ1. mold のソースコードを取得する まず、mold の git repository を clone します。
minami@chromium-dev-20210227:~$ git clone https://github.com/rui314/mold.git minami@chromium-dev-20210227:~$ ls mold minami@chromium-dev-20210227:~$ cd mold/ mold は自身が依存する mimalloc と oneTBB を git submodule として利用しているので、git submodule update --init を実行してこれらのソースコードを取得します。...</p></div><footer class=entry-footer><span title='2021-02-28 12:00:00 +0900 +0900'>February 28, 2021</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Nao Minami</footer><a class=entry-link aria-label="post link to mold の Build 手順メモ" href=https://south37.link/posts/20210228-build-mold/></a></article><article class=post-entry><header class=entry-header><h2>mold と呼ばれる高速なリンカを利用して Chromium を Build してみる</h2></header><div class=entry-content><p>はじめに 現在、広く使われているリンカの中でもっとも高速なものとして有名なのは LLVM project の LLD でしょう。LLD のパフォーマンスについては、公式 document に以下のような benchmark が掲載されていて、GNU ld, GNU gold などと比較して圧倒的に早いという結果が示されています。
Program | Output size | GNU ld | GNU gold w/o threads | GNU gold w/threads | lld w/o threads | lld w/threads ffmpeg dbg | 92 MiB | 1.72s | 1.16s | 1.01s | 0.60s | 0.35s mysqld dbg | 154 MiB | 8.50s | 2.96s | 2.68s | 1.06s | 0.68s clang dbg | 1....</p></div><footer class=entry-footer><span title='2021-02-28 06:00:00 +0900 +0900'>February 28, 2021</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Nao Minami</footer><a class=entry-link aria-label="post link to mold と呼ばれる高速なリンカを利用して Chromium を Build してみる" href=https://south37.link/posts/20210228-chromium-with-mold/></a></article><article class=post-entry><header class=entry-header><h2>kind (Kuberenetes in Docker) に deep dive してみる</h2></header><div class=entry-content><p>kuKubernetes の Install Tools というページでは、kubernetes を local で動かすための tool として kind が紹介されています。今日はこの kind について内部構造及び使い方を見てみます。
kind とは kind は「Docker container の中で Kubernetes を動かすことが出来るツール」です。kind という命名は「Kubernetes in Docker」から来ていて、K-in-D という頭文字をとったものになっています。
kind については KubeCon + CloudNativeCon で何度か紹介されているようです。例えば KubeCon + CloudNativeCon North America 2019 における以下の “Deep Dive: Kind” というトーク では、「kind とは何か？」について内部実装など含めて紹介されています。
上記のトークについて簡単に summary を書くと、kind は以下のようなものとして紹介されています。
Docker container として Node（をシミュレートする container）を動かし、その中で Kubernetes を動かすツール Node image の中に、Kubernetes を動かすために必要な全てを詰める kubelet kubeadm docker systemd core images (Kuberentes にとって重要な container image) etcd coredns pause kube-apiserver etc....</p></div><footer class=entry-footer><span title='2020-12-30 00:00:00 +0900 +0900'>December 30, 2020</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Nao Minami</footer><a class=entry-link aria-label="post link to kind (Kuberenetes in Docker) に deep dive してみる" href=https://south37.link/posts/20201230-kind/></a></article><article class=post-entry><header class=entry-header><h2>BigQuery の内部実装の変遷について</h2></header><div class=entry-content><p>BigQuery（正確にはそのクエリエンジンである Dremel）の内部実装の変遷をまとめた以下のブログポストおよび論文を読みました。
https://medium.com/google-cloud-jp/i-read-dremel-a-decade-of-interactive-sql-analysis-at-web-scale-ca2a015a522a
https://research.google/pubs/pub49489/
とても面白い内容で、Twitter にメモをポストしたのですが、後で参照しやすいようにブログにも同じ内容を載せておきます。
BigQuery（正確にはそのクエリエンジンである Dremel）の内部実装の変遷をまとめた論文の解説ブログ。面白かった。https://t.co/s9UaH4MjBS
— south37/Nao Minami (@south37777) December 28, 2020 解説対象の論文は "Dremel: A Decade of Interactive SQL Analysis at Web Scale"。上記ブログポストでは 3 章の Disaggregation と 5 章の Serverless Computing をピックアップして解説していたが、より網羅的に知りたい場合 & 原文を読みたい場合はこちらを読むと良い。https://t.co/XolZ7fMXFY
— south37/Nao Minami (@south37777) December 28, 2020 以下、雑なメモ。まず前提として 2010 年の Dremel についての最初の論文である "Dremel: Interactive Analysis of Web-Scale Datasets" の 6 章 Query Execution は目を通しておくと良い。Dremel が Query をどう実行するかが説明されている。https://t.co/A98EC7oBqE
— south37/Nao Minami (@south37777) December 28, 2020 Dremel は「巨大なデータに対しての解析 query」である入力 query を「小さなデータに対しての解析 query」の集合に分解する。分解は 2010 年時点では tree の形で行われて、leaf query は storage からデータを読み取る形で実行される。中間 node は「child から集めたデータに対する query」を実行。...</p></div><footer class=entry-footer><span title='2020-12-28 06:00:00 +0900 +0900'>December 28, 2020</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Nao Minami</footer><a class=entry-link aria-label="post link to BigQuery の内部実装の変遷について" href=https://south37.link/posts/20201228-bigquery/></a></article><article class=post-entry><header class=entry-header><h2>手を動かして学ぶコンテナ標準 - Container Runtime 編</h2></header><div class=entry-content><p>コンテナ標準化の現状と Kubernetes の立ち位置について というブログではコンテナ標準の現状についてまとめてみました。
また、手を動かして学ぶコンテナ標準 - Container Image と Container Registry 編 というブログでは Container Image と Container Registry について手を動かして学んでみました。
このブログでは、runc, containerd などの Container Runtime について、実際に手を動かして学んでみたいと思います。
なお、前回のブログ 同様、基本的にこのブログ内のコマンドは Linux で実行するものとします（自分は MacOS で Vagrant で Ubuntu VM を立てて実験してます）。
runc を動かしてみる runc は Low-Level Container Runtime と呼ばれるもので、OCI Runtime Specification に準拠した CLI tool となっています。実際に runc を動かしてみることで、Container Runtime に対して理解を深めてみましょう。
まず runc の install ですが、自分が試している ubuntu-20.04 では apt で install することができます。
vagrant@vagrant:~$ sudo apt update -y vagrant@vagrant:~$ sudo apt install -y runc vagrant@vagrant:~$ which runc /usr/sbin/runc help を見てみると以下のような内容になっていて、container を操作するために必要な各種 subcommand が存在することがわかります。実は、これらの subcommand によって OCI Runtime Specification の Runtime and Lifecycle で定義された「Operations」 の機能が提供されています。ただし、見比べてみると分かりますが runc 自体はよりリッチな機能を提供しているようです。...</p></div><footer class=entry-footer><span title='2020-12-11 00:00:00 +0900 +0900'>December 11, 2020</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Nao Minami</footer><a class=entry-link aria-label="post link to 手を動かして学ぶコンテナ標準 - Container Runtime 編" href=https://south37.link/posts/20201211-container-3/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://south37.link/posts/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2022 <a href=https://south37.link/>South37's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>